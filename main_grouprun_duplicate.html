

<!DOCTYPE html>
<html>

<head>

    <title>API Flow Visualization</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
<!-- Bootstrap CSS -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;

        }
       

        .main_flow_wraper{ display: flex;width: 100%; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            overflow: hidden;
            display: flex;
            height: 110%;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;}
        .main_flow_wraper .save-button-container{top: 120px !important}
        .main_container:has(.main_flow_wraper){min-width: 100%;}
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            overflow: hidden;
            display: flex;
            height: 100vh;
        }

        .navigation {
            flex-grow: 1;
            width: 280px;
            background-color: #f8f9fa;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #dee2e6;
            position: relative;
            z-index: 100;
        }
        #inputContainer {
    width: 250px;
    padding: 1rem;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    overflow-y: auto;
}
.add-flow-button {
    width: 100%;
    padding: 5px 2px 5px 2px;
    margin-bottom: 1rem;
    background-color: #3b82f6;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    transition: background-color 0.2s;
}
.add-flow-button i {
    font-size: 0.875rem;
}
        .add-flow-button:hover {
    background-color: #2563eb;
}

        .flow-list {
            padding: 10px;
        }

        .flow-item {
    width: 100%;
    padding: 0.75rem 1rem;
    text-align: left;
    background-color: #f9fafb;
    border: 1px solid #e5e7eb;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s;
}

.flow-item:hover {
    background-color: #f3f4f6;
    border-color: #d1d5db;
}
.flow-item:active {
    background-color: #e5e7eb;
}

        .search-wrapper {
            margin-bottom: 16px;
        }

        .search-input-container {
            position: relative;
            display: flex;
            align-items: center;
        }

        .search-input {
            width: 100%;
            padding: 8px 40px 8px 12px;
            /* Added right padding for icon */
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 14px;
            background-color: white;
        }

        .search-icon-button {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            background-color: transparent;
            border: none;
            padding: 8px 12px;
            color: #0d6efd;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .search-icon-button:hover {
            color: #0b5ed7;
        }

        .highlight {
            background-color: gray  !important;
        }

        .canvas-container {
            width: 70%;
            /* Increase width to make it more prominent */
            overflow-y: auto;
            position: relative;
            background: white;
        }

        #canvas {
            min-height: 1000vh;
            background: linear-gradient(90deg, rgba(0, 0, 0, .03) 1px, transparent 1px),
                linear-gradient(rgba(0, 0, 0, .03) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .result-container {
            width: 330px;
            background-color: #f8f9fa;
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid #dee2e6;
            position: relative;
        }

        .blockelement {
            padding: 8px 12px;
            margin: 6px 0;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            cursor: move;
            transition: all 0.2s ease;
        }

        .blockelement:hover {
            background: #f8f9fa;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            transform: translateX(2px);
        }

        .blockelement.dragging {
            opacity: 0.5;
            background: #e3f2fd;
        }

        .method-url-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .method-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            white-space: nowrap;
        }

        .method-get {
            background: #e3f2fd;
            color: #1976d2;
        }

        .method-post {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .method-put {
            background: #fff3e0;
            color: #f57c00;
        }

        .method-delete {
            background: #fce4ec;
            color: #c2185b;
        }

        .url-text {
            font-size: 14px;
            color: #333;
            flex: 1;
            word-break: break-all;
        }



        .block {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            min-width: 200px;
            max-width: 300px;
            height: auto !important;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            cursor: move;
            position: absolute;
            font-size: 13px;
            display: flex;
            flex-direction: column;
            gap: 8px;

    transition: box-shadow 0.3s ease-in-out;

        }

        /* Hide request/response cards in canvas */
        .block .card {
            display: none;
        }

        /* Style for cards in result container */
        .result-container .card {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 6px;
        }

        .result-container .request-card {
            background-color: #e9f7ef;
            border: 1px solid #c5f6c4;
            font-size: small;
        }

        .result-container .response-card {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            font-size: small;

        }

        /* Modal container */
.modal-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;

    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
     pointer-events: none;

}

/* Modal hidden state */
.hidden {
    display: none;
}

/* Modal content for add flow button */
.modal-content {
    background: #ffffff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    max-width: 345px;
    position: relative;
    cursor: grab;
    pointer-events: auto;
    z-index: 1050;
    margin: 15% auto;
    width: 30%;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    text-align: center;
}

/* Close button */
.close-modal {
    position: absolute;
    top: 10px;
    right: 10px;
    font-size: 1.5em;
    font-weight: bold;
    color: #333;
    cursor: pointer;
}

        .card-header h5 {
            margin: 0;
            padding: 5px 0;
        }

        .no-details-message {
            color: #666;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }

        /* Update existing connection line style */
        .connection-line {
            stroke: #2196f3;
            stroke-width: 2;
            fill: none;
            transition: d 0.3s ease-in-out;
        }

        /* Add hover effect */
        .connection-line:hover {
            stroke: #1565c0;
            stroke-width: 3;
        }

        /* Animation for new connections */
        .animated-connection {
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            animation: drawLine 1s ease-out forwards;
        }

        @keyframes drawLine {
            to {
                stroke-dashoffset: 0;
            }
        }

        /* Update connection point style */
        .connection-point {
            width: 10px;
            height: 10px;
            background: #2196f3;
            border: 2px solid #1565c0;
            border-radius: 50%;
            position: absolute;
            cursor: pointer;
            z-index: 10;
            transition: all 0.2s ease;
            box-shadow: 0 0 4px rgba(33, 150, 243, 0.4);
        }

        /* Position for each connection point */
        .connection-point.right {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connection-point.left {
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connection-point.top {
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
        }

        .connection-point.bottom {
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
        }

        .connection-point:hover {
            transform: scale(1.2);
            box-shadow: 0 0 8px rgba(33, 150, 243, 0.6);
        }

        .connection-point.right:hover {
            transform: translateY(-50%) scale(1.2);
        }

        .connection-point.left:hover {
            transform: translateY(-50%) scale(1.2);
        }

        .connection-point.top:hover {
            transform: translateX(-50%) scale(1.2);
        }

        .connection-point.bottom:hover {
            transform: translateX(-50%) scale(1.2);
        }

        .connection-point.active {
            background: #1565c0;
            border-color: #0d47a1;
            box-shadow: 0 0 12px rgba(33, 150, 243, 0.8);
        }

        .connection-line {
            stroke: #2196f3;
            stroke-width: 1;
            fill: none;
            transition: d 0.3s ease-in-out;
            cursor: pointer;
            pointer-events: all;
            /* Enable interactions with the line */
        }

        .connection-line:hover {
            stroke: #ff4444;
            stroke-width: 1;
        }

        /* Add a tooltip style */
        .connection-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
        }

        .remove-button {
            background-color: #d32f2f;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 14px;
            text-align: center;
            cursor: pointer;
            z-index: 10;
            margin-left: 10px;
        }

        .remove-button:hover {
            background-color: #b71c1c;
        }

        .block-heading {
            display: flex;
            justify-content: space-between;
            padding: 5px 15px;
            background: lightgrey;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            margin: 8px 0;
            transition: all 0.2s ease;
            font-size: smaller;
            cursor: default;
        }


        .block-header {
            display: flex;
            align-items: center;
            background-color: #ffdb1b5c;
    padding: 5px;
    border-radius: 5px;
        }
        .block-title {
            font-weight: 600;
            color: #333;
            margin-right: auto;
        }

        .block-content {
  display: flex;
  flex-direction: column;
}

.content-row {
  display: flex;
  align-items: center;
  padding: 0px 8px 0px 8px
}

.validate-row {
  display: flex;
  align-items: center;
  padding-left: 8px;
}

.validate-text {
  font-size: 13px;
  color: #4caf50;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  border-radius: 4px;
  transition: background-color 0.2s ease;
}

.validate-text:hover {
  background-color: #e8f5e9;
}

.validate-text i {
  font-size: 12px;
}


        .url-input {
            flex: 1;
            border: none;
            background: transparent;
            padding: 4px;
            margin-right: 8px;
            font-family: monospace;
        }

        .action-buttons {
            display: flex;
            gap: 8px;
        }

        .action-button {
            background: none;
            border: none;
            cursor: pointer;
            color: #666;
            padding: 4px;
        }

        .action-button:hover {
            color: #333;
        }

        .toggle-button {
            width: 24px;
            height: 24px;
            font-size: 16px;
            line-height: 24px;
            text-align: center;
            padding: 0;
            margin-left: 10px;
            background: none;
            border: none;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .toggle-button:active {
            transform: scale(0.9);
        }

        /* Hide details container in sidebar */
        .navigation .details-container {
            display: none;
        }

        .details-container {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
        }

        .tab-container {
            display: flex;
            border-bottom: 1px solid #dee2e6;
            margin-bottom: 20px;
        }

        .tab {
            padding: 8px 16px;
            cursor: pointer;
            border: none;
            background: none;
            color: #6c757d;
        }

        .tab.active {
            color: #0d6efd;
            border-bottom: 2px solid #0d6efd;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-control {
            display: block;
            width: 100%;
            padding: 8px 12px;
            font-size: 14px;
            line-height: 1.5;
            color: #495057;
            background-color: #fff;
            border: 1px solid #ced4da;
            border-radius: 4px;
            transition: border-color 0.15s ease-in-out;
        }

        .form-control:focus {
            border-color: #80bdff;
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, .25);
        }

        .collapsible-section {
            border: 1px solid #dee2e6;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .collapsible-header {
            padding: 10px 15px;
            background-color: #e9ecef;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .collapsible-content {
            padding: 15px;
            border-top: 1px solid #dee2e6;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #212529;
        }

        .arrow-icon {
            transition: transform 0.3s ease;
        }

        .arrow-icon.rotated {
            transform: rotate(180deg);
        }


        .tabs-wrapper {
            position: relative;
            margin-bottom: 20px;
        }

        .tabs {
            display: flex;
            gap: 2px;
            border-bottom: 2px solid #eee;
        }

        .tab-button {
            padding: 12px 24px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tab-button i {
            font-size: 14px;
        }

        .tab-button:hover {
            color: #2196f3;
        }

        .tab-button.active {
            color: #2196f3;
        }

        .tab-button.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 100%;
            height: 2px;
            background: #2196f3;
            transition: all 0.3s ease;
        }


        .tab-pane {
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .tab-pane.active {
            display: block;
            opacity: 1;
        }

        .no-details-message {
            color: #666;
            font-style: italic;
            text-align: center;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 6px;
            margin: 10px 0;
        }

        /* Form Styling */
        .form-container {
            background: #fff;
            padding: 20px;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .form-group {
            margin-bottom: 15px;
        }

        .btn-primary {
            background: #2196f3;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .btn-primary:hover {
            background: #1976d2;
        }
        .save-button-container {
        display: flex;
    position: fixed;
    top: 4%;
    right: 3%;
    transform: translateY(-50%); /* Center vertically */
    z-index: 1000;

}

.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.5);
}



.modal-actions {
    margin-top: 20px;
    display: flex;
    justify-content: center;
    gap: 10px;
}

.modal-button {
    padding: 10px 20px;
    font-size: 14px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

.modal-button:hover {
    background-color: #ddd;
}

.close {
    color: #aaa;
    float: right;
    font-size: 24px;
    font-weight: bold;
    cursor: pointer;
}

.close:hover,
.close:focus {
    color: black;
    text-decoration: none;
    cursor: pointer;
}

.save-button {
margin-right: 10px;
    background-color: #2196f3;
    color: white;
    border: none;
    padding: 5px 10px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    transition: all 0.2s ease;
}

.save-button:hover {
    background-color: #1976d2;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.save-button.saved {
    background-color: #4caf50;
}

.save-button.error {
    background-color: #f44336;
}

.save-button i {
    font-size: 16px;
}
.validate-text {
    margin-top: 8px;
    font-size: 0.9em;
    color: #555;
    text-align: center;
}
.flow-container {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}
        .drag-handle {
    cursor: move;
    background-color: #f1f1f1;
    padding: 10px;
    text-align: right;
}
        .drag-handle {
    cursor: grab;
    background-color: #f1f1f1;
    padding: 10px;
    text-align: right;
    border-bottom: 1px solid #ccc;
}

.drag-handle:active {
    cursor: grabbing;
}

.hidden {
    display: none;
}

.tabs-wrapper {
    padding: 10px;
}
.dropdown-wrapper {
  position: relative;
  display: inline-block;
  width: 100%;
  max-width: 332px;
  margin-top: 20px
}

.dropdown-label {
  display: block;
  font-size: 14px;
  font-weight: 500;
  color: #333;
  margin-bottom: 8px;
}

.function-dropdown {
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  background-color: #fff;
  border: 1px solid #ccc;
  border-radius: 4px;
  color: #333;
  font-size: 14px;
  padding: 10px 40px 10px 16px;
  width: 100%;
  height: 45px;
  cursor: pointer;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 16px center;
  background-size: 24px;
}

.function-dropdown:focus {
  outline: none;
  border-color: #007bff;
  box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
}

.function-dropdown option {
  background-color: #fff;
  color: #333;
}
    .form-group {
        margin-bottom: 20px;
    }
    .form-label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
    }
    .form-control-sm {
        width: 200px;
        padding: 4px 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 0.875rem;
    }
    .dropdown-wrapper {
        margin: 20px;
    }
    textarea.form-control-sm {
        min-height: 100px;
    }
    #function-form {
        margin-top: 20px;
    }
        .modal-content-network {
    position: relative; /* Ensure child elements can be positioned relative to the modal box */
    overflow: hidden;
}

.save-button-network-wrapper {
    position: absolute;
    bottom: 10px; /* Distance from the bottom edge of the modal */
    right: 10px; /* Distance from the right edge of the modal */
}

.save-button-network {
    background-color: #007bff; /* Bootstrap primary button color */
    color: white;
    border: none;
    border-radius: 5px;
    padding: 0.5rem 1rem;
    cursor: pointer;
    font-size: 0.9rem;
}

.save-button-network:hover {
    background-color: #0056b3; /* Darker shade for hover effect */
}
.save-button:disabled {
    background-color: rgba(0, 0, 0, 0.2); /* Transparent background */
    color: rgba(0, 0, 0, 0.5);           /* Faded text color */
    cursor: not-allowed;                /* Show 'not allowed' cursor */
    pointer-events: none;               /* Disable all interactions */
}
.save-button.saved {
    background-color: transparent; /* Transparent background */
    color: #28a745;               /* Green text color */
    pointer-events: none;         /* Disable interactions */
    cursor: default;              /* Default cursor */
}
.important-position {
    left: 0px !important;
    top: 0px !important;
}

    </style>
</head>

<body>
    
    {% extends  'easyauto_base_template.html' %}
    {% block main %}
    {% load crispy_forms_tags %}
    {% load static %}
    <div class="main_flow_wraper"> 
<div id="inputContainer">
    <!-- Add Flow Button -->
    <button class="add-flow-button">
        <i class="fas fa-plus"></i>
        <span>Add Flow</span>
    </button>

    <!-- Modal -->


    <form method="get" id="flowSelectForm">
        {% csrf_token %}
        <input type="hidden" id="selectedFlow" name="selectedFlow" value="">
        <input type="hidden" id="deletedFlow" name="deletedFlow" value="">
        <div class="flow-container">
            {% for flow in flow_list %}
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 5px 0;">
                <button type="submit" class="flow-item" data-flow-id="{{ flow }}" 
                style="
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: calc(100% - 30px);
                padding: 5px;
                margin-right: 5px;">
                    {{ flow }}
                </button>
                <i 
                class="fas fa-trash delete-flow" 
                data-delete-flow-id="{{ flow }}" 
                style="cursor: pointer; margin-left: 10px;">
            </i>
            </div>
            {% endfor %}
        </div>
        
    </form>
</div>

<!-- Modal for entering flow name -->
<div id="flowNameModal" class="modal">
    <div class="modal-content important-position">
        <div style="display: flex; justify-content: space-between;">
            <h6>Enter Flow Name</h6>
            <span class="close" id="flowNameCancelButton" style="margin-top: -14px;">&times;</span>
      
        </div>
        
        <input type="text" id="flowNameInput" placeholder="Enter a flow name"/>
        <div class="modal-actions">
            <button id="flowNameSubmitButton" class="modal-button">OK</button>
            <button id="flowNameCancelButton" class="modal-button">Cancel</button>
        </div>
    </div>
</div>

  <!-- Navigation container (right side) -->
  <div class="navigation ml-3">
    <div class="search-wrapper">
        <div class="search-input-container">
            <input type="text" id="searchInput" placeholder="Search..." class="search-input">
            <button onclick="performSearch()" class="search-icon-button">
                <i class="fas fa-search"></i>
            </button>
        </div>
    </div>
    {% if 'type' in form.keys %}
        {% for section, data in form.items %}
            {% if section != "functions" and section != "type" %}
                <div class="block-heading" draggable="false">
                    <h6 draggable="false">{{ section }}</h6>
                    <button class="toggle-button" onclick="toggleUrls(event)" draggable="false">▼</button>
                </div>
                <div class="url-list" style="display: none;">
                    {% if section in form %}
                        {% for device, details in data.items %}
                            <div class="blockelement draggable" draggable="true" data-section="{{ section }}" data-platform="{{ details.platform }}" data-device="{{ device }}" data-url="{{ device }}">
                                <div class="method-url-container">
                                    <span class="platform-text">{{ details.platform }}</span>
                                    <span class="device-text">{{ device }}</span>
                                </div>
                            </div>
                        {% endfor %}
                    {% endif %}
                </div>
            {% endif %}
        {% endfor %}
    {% else %}
        {% for testbed, testbed_data in form.items %}
            <div class="block-heading" draggable="false">
                <h6 draggable="false">{{ testbed }}</h6>
                <button class="toggle-button" onclick="toggleUrls(event)" draggable="false">▼</button>
            </div>
            <div class="url-list" style="display: none;">
                {% for section, data in testbed_data.items %}
                    <div class="section-container">
                        <div class="block-heading secondary" draggable="false">
                            <h6 draggable="false">{{section }}</h6>
                            <button class="toggle-button" onclick="toggleUrls(event)" draggable="false">▼</button>
                        </div>
                        <div class="url-list nested" style="display: none;">
                            {% for url, methods in data.urls.items %}
                                {% for method, value in methods.items %}
                                    <div class="blockelement draggable" draggable="true" 
                                        
                                        data-section="{{ testbed }}-{{ section }}" 
                                        data-method="{{ method|upper }}" 
                                        data-url="{{ url }}"
                                        data-request-body="{{ value.requestBody }}" 
                                        data-response="{{ value.responses }}" 
                                        data-parameters="{{value.parameters}}">
                                        <div class="method-url-container">
                                            <span class="method-badge method-{{ method|lower }}">{{ method }}</span>
                                            <span class="url-text">{{ url }}</span>
                                        </div>
                                    </div>
                                {% endfor %}
                            {% endfor %}
                        </div>
                    </div>
                {% endfor %}
            </div>
        {% endfor %}
    {% endif %}
</div>
     
    <style>
    .section-container {
      margin-left: 20px;
    }
     
    .block-heading.secondary {
      font-size: 0.9em;
    }
     
    .url-list.nested {
      margin-left: 15px;
    }
    </style>
     

<div class="canvas-container">

    <div id="canvas" style="overflow: auto;">
        <svg id="connections" width="100%" height="100%"
             style="position: absolute; top: 0; left: 0; pointer-events: none;">
            <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#2196f3"/>
                </marker>
            </defs>
        </svg>

    </div>
</div>

<form id="flowForm" method="post">
    {% csrf_token %}
<input type="hidden" id="flowStructureData" name="flowStructureData" value="">
<input type="hidden" id="flowDisplayValue" name="flowDisplayValue" value="">
<div class="save-button-container">
    <button type="button" id="saveFlowButton" class="save-button" disabled>
        <i class="fas fa-save"></i> Save Flow
    </button>
    
<button type="button"
        id="executeButton"
        class="save-button text-decoration-none d-flex align-items-center"
        data-base-url="{% url 'testscenario:main-developflow-info' '' %}"
        onclick="handleExecuteClick(this, '{{ json_path }}')"
        title="Configure">
        
<i class="fa fa-cogs" aria-hidden="true"></i>
<span class="ms-2">Execute</span>
</button>
<i 
  class="fa fa-cog" 
  aria-hidden="true" 
  id="settingsIcon" 
  style="color: grey; cursor: pointer; font-size: 18px; margin-top: 6px;
    margin-right: 10px;">
</i>


<div id="flowDisplayArea" style="display: none;">

</div>
</div>

</form>
</div>
<div id="result-modal" class="modal-container hidden">
    <div class="modal-content" style="max-height: 30rem; min-height: 30rem; width: 400px;">
      <span class="close-modal" onclick="toggleModal()">×</span>
  
      <!-- Network Case -->
      {% if form.type == 'network' %}
      <div class="tabs-wrapper">
        <div class="tabs">
          <button class="tab-button active" data-tab="execute">
            <i class="fa fa-cogs"></i> Execute
          </button>
        </div>
        <div class="dropdown-wrapper">
          <select id="function-dropdown" class="function-dropdown">
            <option value="select" disabled selected>Select</option>
            {% for key in form.functions.keys %}
            <option value="{{ key }}">{{ key }}</option>
            {% endfor %}
          </select>
          <div id="function-form"></div>
        </div>
      </div>
      {% else %}
      <!-- Non-Network Case -->
      <div class="tabs-wrapper">
        <div class="tabs">
          <button class="tab-button active" data-tab="request">
            <i class="fa fa-paper-plane"></i> Request
          </button>
          <button class="tab-button" data-tab="response">
            <i class="fa fa-reply"></i> Validate
          </button>
        </div>
      </div>
      <div id="details-container">
        <div class="tab-pane active" id="request"></div>
        <div class="tab-pane" id="response"></div>
      </div>
      {% endif %}
  
      <!-- Save Button -->
      {% if form.type == 'network' %}
      <div class="save-button-network-wrapper">
        <button class="save-button-network" onclick="saveFunction()">Save</button>
      </div>
      {% else %}
      <div class="save-button-network-wrapper">
        <button class="save-button-network" onclick="saveFunction2()">Save</button>
      </div>
      {% endif %}
      
    </div>
  </div>
  
  
</div>
<template id="block-template">
    <div class="block">
        <div class="block-parameters" style="display: none"></div>
        <div class="block-header">
            <span class="block-title"></span>
            <span class="block-num"></span>
            <button class="action-button delete-button">
                <i class="fas fa-trash"></i>
            </button>

        </div>

        <div class="block-content">
            <div class="content-row">
                <span class="method-badge"></span>
                <input type="text" class="url-input" readonly>
                <div class="action-buttons" onclick="toggleModal(event)">
                    <button class="action-button edit-button" onclick="toggleModal(event)">
                        <i class="fas fa-pen"></i>
                    </button>
                </div>
            </div>
            <div class="validate-row">
                <div class="validate-text">
                    <i class="fas fa-check-circle"></i>
                    Validate
                </div>
            </div>
        </div>
        <div class="connection-point right"></div>
        <div class="connection-point left"></div>
        <div class="connection-point top"></div>
        <div class="connection-point bottom"></div>
    </div>
</template>
<div class="modal fade" id="settingsModal" tabindex="-1" aria-labelledby="settingsModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="settingsModalLabel">Settings</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
        
          <form>
            <!-- Dropdown 1 -->
            <div class="mb-3">
            
              <select class="form-select" id="dropdown1">
                <option value="" selected>Select Testbed</option>
                {% for item in testbed_list %}
                <option value="{{ item }}">{{ item }}</option>
                {% endfor %}
              </select>
            </div>
            <!-- Dropdown 2 -->
            <div class="mb-3">
             
              <select class="form-select" id="dropdown2">
                <option value="" selected>Select Functionality</option>
               
              </select>
            </div>
          </form>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          <button type="button" class="btn btn-primary">Save</button>
        </div>
      </div>
    </div>
  </div>
  <!-- Bootstrap Bundle with Popper -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>

  <script>
     const scenarioList = {{ scenario_list|safe }};
   

    const dropdown1 = document.getElementById('dropdown1');
    const dropdown2 = document.getElementById('dropdown2');


  // Listen for changes in the first dropdown
  dropdown1.addEventListener('change', function () {
    const selectedTestbed = dropdown1.value;

    // Clear the second dropdown
    dropdown2.innerHTML = '<option value="" selected>Select Functionality</option>';

    // Check if the selected testbed exists in the scenarioList
    if (scenarioList[selectedTestbed]) {
      // Populate the second dropdown with the corresponding scenario list
      scenarioList[selectedTestbed].forEach(function (scenario) {
        const option = document.createElement('option');
        option.value = scenario;
        option.textContent = scenario;
        dropdown2.appendChild(option);
      });
    }
  });

    document.getElementById("settingsIcon").addEventListener("click", function () {
      // Use Bootstrap's modal function to show the modal
      var modal = new bootstrap.Modal(document.getElementById('settingsModal'));
      modal.show();
    });
  </script>
  
<script>
    // Store Django template variable in a global JS variable
    window.EXISTING_FLOW = JSON.parse('{{ EXISTING_FLOW|escapejs|safe }}');
</script>

<script>
    function handleExecuteClick(button, jsonPath) {
        let modifiedPath = jsonPath;
        const flowDisplayArea = document.getElementById('flowDisplayArea');
        const flowIdFromDisplay = flowDisplayArea.innerHTML;  // This gets the flowId from the HTML element

        const baseUrl = button.getAttribute('data-base-url');

        if (jsonPath.includes('/.json')) {
            modifiedPath = jsonPath.replace('/.json', `/${flowIdFromDisplay}.json`);
        }
        window.open(baseUrl + modifiedPath, '_blank');
    }
    </script>

<script>

document.addEventListener('DOMContentLoaded', () => {
   
    let activeBlock = null;
    let currentFormValues = {};

    const dropdown = document.getElementById('function-dropdown');
    const functionForm = document.getElementById('function-form');

    const detailsContainer = document.getElementById('details-container');

    if (!dropdown) {
        console.error('Dropdown element with ID "function-dropdown" not found.');
        return;
    }

    // Function to validate configuration
    function validateConfiguration(configData) {
        if (!configData || typeof configData !== 'string') {
            return false;
        }

        try {
            // Remove comments
            const cleanConfig = configData.replace(/!.*/g, '').trim();

            // Basic syntax checks
            const hasInvalidChars = /[^a-zA-Z0-9\s\-_.,!@#$%^&*()[\]{}|\\/<>?:;'"+=`~\n\r\t]/.test(cleanConfig);
            if (hasInvalidChars) {
                return false;
            }

            // Check for balanced brackets and parentheses
            const brackets = [];
            const openBrackets = "({[";
            const closeBrackets = ")}]";

            for (let char of cleanConfig) {
                if (openBrackets.includes(char)) {
                    brackets.push(char);
                } else if (closeBrackets.includes(char)) {
                    const lastOpen = brackets.pop();
                    const expectedOpen = openBrackets[closeBrackets.indexOf(char)];
                    if (lastOpen !== expectedOpen) {
                        return false;
                    }
                }
            }

            if (brackets.length !== 0) {
                return false;
            }

            // Check for minimum content
            if (cleanConfig.length < 10) {
                return false;
            }

            return true;
        } catch (error) {
            console.error('Configuration validation error:', error);
            return false;
        }
    }

    // Function to check if it's a configuration type
    function isConfigurationType(selectedKey) {
        return selectedKey === 'configure';
    }

    // Function to create form elements based on the argList
    function createFormElements(argList) {
        functionForm.innerHTML = '';
        currentFormValues = {}; // Reset current form values

        Object.entries(argList).forEach(([key, value]) => {
            const formGroup = document.createElement('div');
            formGroup.className = 'form-group';

            const label = document.createElement('label');
            label.className = 'form-label';
            label.textContent = key.charAt(0).toUpperCase() + key.slice(1).replace(/_/g, ' ');
            formGroup.appendChild(label);

            let inputElement;

            if (value.type === 'select') {
                inputElement = document.createElement('select');
                inputElement.className = 'form-control-sm';

                if (Array.isArray(value.initial)) {
                    value.initial.forEach(option => {
                        const optionElement = document.createElement('option');
                        optionElement.value = option;
                        optionElement.textContent = option;
                        inputElement.appendChild(optionElement);
                    });
                }
                inputElement.value = currentFormValues[key] || '';
            } else if (value.type === 'text_area') {
                inputElement = document.createElement('textarea');
                inputElement.className = 'form-control-sm';
                inputElement.value = currentFormValues[key] || value.initial || '';
            } else {
                inputElement = document.createElement('input');
                inputElement.type = 'text';
                inputElement.className = 'form-control-sm';
                inputElement.style.width = '200px';
                inputElement.placeholder = key;
                inputElement.value = currentFormValues[key] || value.initial || '';
            }

            inputElement.addEventListener('change', (e) => {
                currentFormValues[key] = e.target.value;
            });

            formGroup.appendChild(inputElement);
            functionForm.appendChild(formGroup);

            currentFormValues[key] = value.initial || '';
        });
    }

    // Function to create configuration form
    function createConfigurationForm(savedValues = {}) {
        const formData = {{ formjson|safe }};
        functionForm.innerHTML = '';
        currentFormValues = savedValues;

        // Create Configuration dropdown
        const configGroup = document.createElement('div');
        configGroup.className = 'form-group';

        const configLabel = document.createElement('label');
        configLabel.className = 'form-label';
        configLabel.textContent = 'Configuration';
        configGroup.appendChild(configLabel);

        const configSelect = document.createElement('select');
        configSelect.className = 'form-control-sm';

        // Add default option
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'Select configuration';
        configSelect.appendChild(defaultOption);

        // Get device configurations
        const deviceName = activeBlock.dataset.device || activeBlock.dataset.url;
<!--        const deviceName = activeBlock.dataset.device;-->
        const sectionName = activeBlock.dataset.section;

        const configs = formData[sectionName]?.[deviceName]?.config || {};

        const configOptions = Object.keys(configs);

        // Add configuration options
        configOptions.forEach(option => {
            const optionElement = document.createElement('option');
            optionElement.value = option;
            optionElement.textContent = option;
            configSelect.appendChild(optionElement);
        });
        const selected_conf = savedValues?.configuration;
        // Set saved configuration if available
        if (selected_conf) {
            configSelect.value = selected_conf;
        }

        configGroup.appendChild(configSelect);
        functionForm.appendChild(configGroup);

        // Create Config data textarea
        const dataGroup = document.createElement('div');
        dataGroup.className = 'form-group';

        const dataLabel = document.createElement('label');
        dataLabel.className = 'form-label';
        dataLabel.textContent = 'Config data';
        dataGroup.appendChild(dataLabel);

        const textarea = document.createElement('textarea');
        textarea.className = 'form-control-sm';

        // Set initial config data if available
        if (savedValues.config_data) {
            textarea.value = savedValues.config_data;
        }

        // Update textarea when configuration changes
        configSelect.addEventListener('change', (e) => {
            const selectedConfig = e.target.value;
            if (selectedConfig && configs[selectedConfig]) {
                const configContent = configs[selectedConfig];

                if (validateConfiguration(configContent)) {
                    textarea.value = configContent;
                    currentFormValues.configuration = selectedConfig;
                    currentFormValues.config_data = textarea.value;

                    const existingError = dataGroup.querySelector('.error-message');
                    if (existingError) {
                        existingError.remove();
                    }
                } else {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'error-message text-red-500 text-sm mt-1';
                    errorDiv.textContent = 'Invalid configuration format. Please check the configuration content.';

                    const existingError = dataGroup.querySelector('.error-message');
                    if (existingError) {
                        existingError.remove();
                    }

                    dataGroup.appendChild(errorDiv);

                    configSelect.value = '';
                    textarea.value = '';
                    currentFormValues.configuration = '';
                    currentFormValues.config_data = '';
                }
            } else {
                textarea.value = '';
                currentFormValues.configuration = '';
                currentFormValues.config_data = '';
            }
        });

        dataGroup.appendChild(textarea);
        functionForm.appendChild(dataGroup);
    }

    // Handle the dropdown change
    dropdown.addEventListener('change', () => {
        const selectedKey = dropdown.value;

        if (!activeBlock) {
            console.warn('No block selected. Please select a block first.');
            return;
        }

        const blockTitle = activeBlock.querySelector('.block-title')?.textContent.trim() || 'Unknown';
        const platform = activeBlock.dataset.platform || 'N/A';
        const device = activeBlock.dataset.device || 'N/A';
        const section = activeBlock.dataset.section || 'N/A';

        const sectionKey = `${section}-${device}`;
        const formData = {{ formjson|safe }};
        let argList = {};

        if (!formData) {
            console.error('formData is not defined.');
            return;
        }

        if (isConfigurationType(selectedKey)) {
            createConfigurationForm(currentFormValues);
        } else if (formData.functions && formData.functions[selectedKey]) {
            const functionData = formData.functions[selectedKey];
            const layout = functionData.layout || {};

            for (let row in layout) {
                const rowArgs = layout[row];
                for (let arg in rowArgs) {
                    const argDetails = rowArgs[arg];
                    let initialValue = argDetails.intial;
                    const inputType = argDetails.input_type;

                    if (initialValue === 'get_list(configuration)') {
                        if (formData[section]?.[device]?.['config']) {
                            initialValue = Object.keys(formData[section][device]['config']);
                        } else {
                            console.warn('Config data not found for', section, device);
                            initialValue = [];
                        }
                    }

                    if (initialValue !== 'get_list(topology)') {
                        argList[arg] = {
                            type: inputType,
                            initial: initialValue
                        };
                    }
                }
            }

            createFormElements(argList);
        }

        const result = {
            option: selectedKey,
            blockTitle,
            device,
            platform,
            section,
        };

    });

    window.saveFunction2 = () => {
       
  console.log("Save function for non-network triggered");
  // Add your logic for the 'non-network' case
};

   // Save function data to local storage
window.saveFunction = () => {

    if (!activeBlock) {
        console.warn('No block selected. Please select a block first.');
        return;
    }

    const blockNum = activeBlock.querySelector('.block-num')?.textContent;
    if (!blockNum) {
        console.warn('No block number found.');
        return;
    }

    const selectedKey = dropdown.value;
    const savedData = JSON.parse(localStorage.getItem('functionData')) || {};

    if (isConfigurationType(selectedKey)) {
        const configSelect = functionForm.querySelector('select');
        const textarea = functionForm.querySelector('textarea');

        if (textarea?.value && !validateConfiguration(textarea.value)) {
            console.warn("Invalid configuration format. Please check the configuration content.");
            return;
        }

        savedData[blockNum] = {
            section: activeBlock.dataset.section,
            device: activeBlock.dataset.device,
            selectedKey: selectedKey,
            platform: activeBlock.dataset.platform,
            formValues: {
                configuration: configSelect?.value || '',
                config_data: textarea?.value || ''
            }
        };
    } else {
        savedData[blockNum] = {
            section: activeBlock.dataset.section,
            device: activeBlock.dataset.device,
            selectedKey: selectedKey,
            formValues: currentFormValues,
            platform: activeBlock.dataset.platform
        };
    }

    localStorage.setItem('functionData', JSON.stringify(savedData));

    // Close the modal after saving
    const modalContainer = document.getElementById('result-modal');
    if (modalContainer) {
        modalContainer.classList.add('hidden');
    }
};

// Toggle modal visibility and load saved data
window.toggleModal = (event) => {
    const blockElement = event?.target?.closest('.block');
    const functionForm = document.getElementById('function-form');
    const modalContainer = document.getElementById('result-modal');
    const modalContent = modalContainer.querySelector('.modal-content');
    let savedData = JSON.parse(localStorage.getItem('functionData')) || {};
    window.FLOW_DATA = window.FLOW_DATA || {};
    const flowDisplayArea = document.getElementById('flowDisplayArea');
    const flowIdFromDisplay = flowDisplayArea.innerHTML;
    let isDragging = false;
    let currentX, currentY, initialX, initialY, xOffset = 0, yOffset = 0;

    // Draggable functionality
    modalContent.addEventListener('mousedown', (e) => {
        // Prevent dragging when interacting with interactive elements like dropdowns
        if (e.target.closest('select') || e.target.closest('input') || e.target.closest('button')) {
            return;
        }
        e.preventDefault();
        isDragging = true;
        initialX = e.clientX - xOffset;
        initialY = e.clientY - yOffset;
        document.addEventListener('mousemove', dragModal);
        document.addEventListener('mouseup', stopDragging);
    });

    function dragModal(e) {
        if (isDragging) {
            currentX = e.clientX - initialX;
            currentY = e.clientY - initialY;
            xOffset = currentX;
            yOffset = currentY;
            setTranslate(currentX, currentY, modalContent);
        }
    }

    function stopDragging() {
        isDragging = false;
        document.removeEventListener('mousemove', dragModal);
        document.removeEventListener('mouseup', stopDragging);
    }

    function setTranslate(xPos, yPos, el) {
        el.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;
    }

    // Clear the form initially
    if (functionForm) {
        functionForm.innerHTML = '';
    }

    if (blockElement) {
        activeBlock = blockElement;
        const blockNum = blockElement.querySelector('.block-num')?.textContent;

        if (blockNum) {
            let data_key;

            if (Object.keys(savedData).length === 0) {
                let flowData = { ...window.FLOW_DATA };
                let hasMatchingFlow = false;

                for (const key in flowData) {
                    if (key === flowIdFromDisplay) {
                        data_key = key;
                        if (flowData.hasOwnProperty(key)) {
                            savedData = flowData[key];
                            hasMatchingFlow = true;
                        }
                    }
                }

                if (!hasMatchingFlow || !savedData[blockNum]) {
                    if (dropdown) {
                        dropdown.value = 'select';
                        if (functionForm) {
                            functionForm.innerHTML = '';
                        }
                    }
                    modalContainer.classList.toggle('hidden');
                    return;
                }

                if (dropdown && savedData[blockNum]?.property?.selectedKey) {
                    dropdown.value = savedData[blockNum].property.selectedKey;
                    const selected = savedData[blockNum].property.selectedKey;

                    if (selected === 'configure') {
                        const config_values = savedData[blockNum]?.property?.formValues;
                        createConfigurationForm(config_values);
                    } else {
                        const formData = {{ formjson|safe }};
                        if (formData.functions && formData.functions[selected]) {
                            const functionData = formData.functions[selected];
                            const layout = functionData.layout || {};
                            let argList = {};

                            for (let row in layout) {
                                const rowArgs = layout[row];
                                for (let arg in rowArgs) {
                                    const argDetails = rowArgs[arg];
                                    if (arg !== 'device') {
                                        argList[arg] = {
                                            type: argDetails.input_type,
                                            initial: savedData[blockNum]?.property?.formValues[arg] || argDetails.initial
                                        };
                                    }
                                }
                            }
                            if (data_key === flowIdFromDisplay) {
                                createFormElements(argList);
                            }
                        }
                    }
                }
            } else {
                if (blockNum === undefined || blockNum === null) {
                    console.warn("blockNum is invalid:", blockNum);
                } else if (!savedData[blockNum]) {
                    const flowData = { ...window.FLOW_DATA };
                    if (
                        flowData[flowIdFromDisplay] &&
                        flowData[flowIdFromDisplay][blockNum] &&
                        flowData[flowIdFromDisplay][blockNum]?.property?.selectedKey
                    ) {
                        if (dropdown) {
                            dropdown.value = flowData[flowIdFromDisplay][blockNum].property.selectedKey;
                            if (functionForm) {
                                functionForm.innerHTML = '';
                            }
                        }
                    } else {
                        if (dropdown) {
                            dropdown.value = 'select';
                            if (functionForm) {
                                functionForm.innerHTML = '';
                            }
                        }
                    }
                } else {
                    const { selectedKey, formValues } = savedData[blockNum];
                    if (dropdown) {
                        dropdown.value = selectedKey;
                        if (isConfigurationType(selectedKey)) {
                            createConfigurationForm(formValues);
                        } else {
                            const formData = {{ formjson|safe }};
                            if (formData.functions && formData.functions[selectedKey]) {
                                const functionData = formData.functions[selectedKey];
                                const layout = functionData.layout || {};
                                let argList = {};

                                for (let row in layout) {
                                    const rowArgs = layout[row];
                                    for (let arg in rowArgs) {
                                        const argDetails = rowArgs[arg];
                                        if (arg !== 'device') {
                                            argList[arg] = {
                                                type: argDetails.input_type,
                                                initial: formValues[arg] || argDetails.initial
                                            };
                                        }
                                    }
                                }
                                currentFormValues = formValues;
                                createFormElements(argList);
                            }
                        }
                    }
                }
            }
        }
    }

    modalContainer.classList.toggle('hidden');

    // Reset modal position if shown
    if (!modalContainer.classList.contains('hidden')) {
        xOffset = 0;
        yOffset = 0;
        setTranslate(0, 0, modalContent);
    }
};



});

</script>

<script>
    document.querySelectorAll('.draggable').forEach(element => {
 element.addEventListener('dragstart', (e) => {
     // Construct the data object to be passed
     const data = {
         url: element.dataset.url || null,
         method: element.dataset.method || null,
         section: element.dataset.section || null,
         requestBody: element.dataset.requestBody || 'N/A',
         response: element.dataset.response || 'N/A',
         parameters: element.dataset.parameters || 'N/A',
         device: element.dataset.device || null,
         platform: element.dataset.platform || null,
        
     };

     // Store the data as a JSON string
     e.dataTransfer.setData('text/plain', JSON.stringify(data));
 });
});

</script>

<script>
    document.addEventListener('DOMContentLoaded', () => {
      const modal = document.getElementById('flowNameModal');
      const flowNameInput = document.getElementById('flowNameInput');
      const modalContent = document.querySelector('.modal-content');
      let isDragging = false;
      let currentX, currentY, initialX, initialY, xOffset = 0, yOffset = 0;
  
      // Open modal
      function openModal() {
        modal.style.display = 'flex';
        flowNameInput.value = '';
        flowNameInput.focus();
        centerModal(); // Center modal when opened
      }
  
      // Close modal
      function closeModal() {
        modal.style.display = 'none';
      }
  
      // Drag start
      function dragStart(e) {
        // Prevent dragging when clicking interactive elements
        if (
          e.target.tagName === 'BUTTON' ||
          e.target.tagName === 'SELECT' ||
          e.target.classList.contains('close-modal') ||
          e.target.tagName === 'I'
        ) {
          return;
        }
  
        isDragging = true;
        initialX = (e.clientX || e.touches[0].clientX) - xOffset;
        initialY = (e.clientY || e.touches[0].clientY) - yOffset;
  
        modalContent.classList.add('dragging');
      }
  
      // Dragging
      function drag(e) {
        if (!isDragging) return;
  
        e.preventDefault();
        currentX = (e.clientX || e.touches[0].clientX) - initialX;
        currentY = (e.clientY || e.touches[0].clientY) - initialY;
  
        xOffset = currentX;
        yOffset = currentY;
  
        setTranslate(currentX, currentY, modalContent);
      }
  
      // Drag end
      function dragEnd() {
        if (!isDragging) return;
  
        isDragging = false;
        modalContent.classList.remove('dragging');
      }
  
      // Set position
      function setTranslate(xPos, yPos, element) {
        element.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;
      }
  
      // Center modal
      function centerModal() {
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const modalWidth = modalContent.offsetWidth;
        const modalHeight = modalContent.offsetHeight;
  
        xOffset = 0;
        yOffset = 0;
  
        modalContent.style.transform = `translate3d(0, 0, 0)`;
        modalContent.style.left = `${(viewportWidth - modalWidth) / 2}px`;
        modalContent.style.top = `${(viewportHeight - modalHeight) / 2}px`;
      }
  
      // Toggle modal visibility
     
      // Attach event listeners
      modalContent.addEventListener('mousedown', dragStart);
      modalContent.addEventListener('touchstart', dragStart);
      document.addEventListener('mousemove', drag);
      document.addEventListener('touchmove', drag, { passive: false });
      document.addEventListener('mouseup', dragEnd);
      document.addEventListener('touchend', dragEnd);
      window.addEventListener('resize', centerModal);
  
      // Initial centering
      centerModal();
    });
  </script>
  
<script>
     const formData = {{ formjson|safe }};
    let selectedPoint = null;
    let connections = [];
    let droppedBlocks = new Set();
    let blockOrder = [];
    let currentFlowId = null;
    let flowStructures = {};
    let flowCount = 0; // Start from 0 to properly track flows
    let tempLine = null;



    function toggleModal(button) {
 
   
    
    const modal = document.getElementById('result-modal');
    const modalContent = modal.querySelector('.modal-content');
    let isDragging = false;
    let currentX, currentY, initialX, initialY, xOffset = 0, yOffset = 0;

    // Toggle the modal visibility
    modal.classList.toggle('hidden');

    // Reset modal position if shown
    if (!modal.classList.contains('hidden')) {
        xOffset = 0;
        yOffset = 0;
        setTranslate(0, 0, modalContent);
    }

    // Add draggable functionality
    modalContent.addEventListener('mousedown', (e) => {
        // Prevent dragging when interacting with dropdowns or other interactive elements
        if (e.target.closest('select') || e.target.closest('input') || e.target.closest('button')) {
            return;
        }
        e.preventDefault();
        isDragging = true;
        initialX = e.clientX - xOffset;
        initialY = e.clientY - yOffset;
        document.addEventListener('mousemove', dragModal);
        document.addEventListener('mouseup', stopDragging);
    });

    function dragModal(e) {
        if (isDragging) {
            currentX = e.clientX - initialX;
            currentY = e.clientY - initialY;
            xOffset = currentX;
            yOffset = currentY;
            setTranslate(currentX, currentY, modalContent);
        }
    }

    function stopDragging() {
        isDragging = false;
        document.removeEventListener('mousemove', dragModal);
        document.removeEventListener('mouseup', stopDragging);
    }

    function setTranslate(xPos, yPos, el) {
        el.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;
    }
}



    document.querySelectorAll('.tab-button').forEach(button => {
        button.addEventListener('click', function () {
            // Remove active class from all buttons
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));

            // Add active class to clicked button
            this.classList.add('active');

            // Show corresponding tab pane
            const tabId = this.dataset.tab;
            document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
        });
    });


    document.addEventListener('DOMContentLoaded', initializeSystem);
    window.FLOW_DATA = {% if existing_flow %}{{existing_flow|safe}}{% else %}{}{% endif %};
    document.addEventListener('DOMContentLoaded', function() {
        // Set up flow buttons
        const flowButtons = document.querySelectorAll('.flow-item');
        flowButtons.forEach(button => {
            button.addEventListener('click', function(e) {
                e.preventDefault();
                const flowId = this.getAttribute('data-flow-id');
                selectFlow(flowId);
            });
        });
    });
    // Add this function to get the highest existing block number
function getHighestBlockNumber() {
    const blocks = document.querySelectorAll('[data-block-id]');
    let highestNum = 0;

    blocks.forEach(block => {
        const blockId = block.getAttribute('data-block-id');
        // Extract the number from block ID (assuming format like "block-1", "block-2", etc.)
        const match = blockId.match(/\d+$/);
        if (match) {
            const num = parseInt(match[0], 10);
            if (!isNaN(num) && num > highestNum) {
                highestNum = num;
            }
        }
    });

    return highestNum;
}
function loadExistingFlow(flowId) {
    let flowStructure = {};
    
    if (!window.FLOW_DATA || Object.keys(window.FLOW_DATA).length === 0) {
        const storedFlows = JSON.parse(localStorage.getItem('apiFlowStructures')) || {};
        window.FLOW_DATA = storedFlows;
       
    }

    const flowData = window.FLOW_DATA[flowId];
    
    if ('requestDetails' in flowData?.functionData || 'responseDetails' in flowData?.functionData) {
        localStorage.setItem('requestDetails', JSON.stringify(flowData?.functionData?.requestDetails));
        localStorage.setItem('responseDetails', JSON.stringify(flowData?.functionData?.responseDetails));
    }
    else{
        localStorage.setItem('functionData', JSON.stringify(flowData?.functionData));
    }
    
    localStorage.setItem('blockData', JSON.stringify(flowData?.blockData))
 clearCanvas();

 connections = [];

 droppedBlocks = new Set();

 blockOrder = [];

 currentFlowId = flowId;

  updateFlowIdDisplay(flowId);




 if (!flowData) {

     console.error(`Flow data for ${flowId} not found!`);

     alert('Selected flow data could not be loaded.');

     return;

 }
 for (let key in flowData) {
    if (key !== 'functionData' && key !== 'blockData') {
        flowStructure[key] = flowData[key];

    }
}
 const sortedBlocks = Object.entries(flowStructure)

     .sort((a, b) => a[1].order - b[1].order);

 // First pass: Create all blocks

 sortedBlocks.forEach(([key, blockData]) => {
     const block = createBlock({

         id: blockData.blockId,

         method: blockData.method,

         url: blockData.url,

         requestBody: blockData.requestBody,

         response: blockData.response,

         section: blockData.section,

         parameters: blockData.parameters,

         blockId: blockData.blockId || key, // Important: Ensure blockId is passed

         blockDetails: blockData.blockDetails

     });

     if (blockData.position) {

         block.style.left = `${blockData.position.x}px`;

         block.style.top = `${blockData.position.y}px`;

     }

     document.getElementById('canvas').appendChild(block);

     makeBlockInteractive(block);

     droppedBlocks.add(blockData.url || key);

     blockOrder.push(blockData.url || key);

 });

    // Update block counter in localStorage
    const highestNumber = getHighestBlockNumber();
    localStorage.setItem('blockCounter', (highestNumber).toString());

    // Second pass: Create connections with retry logic
    const retryInterval = 100;
    const maxRetries = 5;
    let retryCount = 0;

    function attemptConnectionCreation() {
        let allConnectionsCreated = true;
        
        sortedBlocks.forEach(([_, blockData]) => {
            if (blockData.connections) {
                blockData.connections.forEach(conn => {
                    const fromBlock = document.querySelector(`[data-block-id="${conn.from}"]`);
                    const toBlock = document.querySelector(`[data-block-id="${conn.to}"]`);
                    
                    const fromPoint = fromBlock?.querySelector(`[data-point-id="${conn.fromPoint}"]`);
                    const toPoint = toBlock?.querySelector(`[data-point-id="${conn.toPoint}"]`);

                    if (fromBlock && toBlock && fromPoint && toPoint) {
                        const connectionExists = connections.some(existing =>
                            (existing.start === fromPoint && existing.end === toPoint) ||
                            (existing.start === toPoint && existing.end === fromPoint)
                        );

                        if (!connectionExists) {
                            createConnection(fromPoint, toPoint);
                        }
                    } else {
                        console.warn('Connection points or blocks not found:', {
                            connection: conn,
                            fromBlock: !!fromBlock,
                            toBlock: !!toBlock,
                            fromPoint: !!fromPoint,
                            toPoint: !!toPoint
                        });
                        allConnectionsCreated = false;
                    }
                });
            }
        });

        if (!allConnectionsCreated && retryCount < maxRetries) {
            retryCount++;
            console.log(`Retry attempt ${retryCount} for creating connections...`);
            setTimeout(attemptConnectionCreation, retryInterval);
        } else if (allConnectionsCreated) {
            console.log('All connections created successfully.');
            updateConnections();
        } else {
            console.warn(`Failed to create all connections after ${maxRetries} attempts.`);
            updateConnections(); // Update anyway to show what was created
        }
    }

    // Start connection creation with a delay to ensure DOM is ready
    setTimeout(attemptConnectionCreation, 200);
}

// Initialize everything when document loads
            document.addEventListener('DOMContentLoaded', function() {
                initializeSVGContainer();
                initializeDragAndDrop();
                setupFlowListeners();
                setupAddFlowButton();

                // Load initial flow if one is selected
                const urlParams = new URLSearchParams(window.location.search);
                const selectedFlow = urlParams.get('selectedFlow');
                if (selectedFlow) {
                    loadExistingFlow(selectedFlow);
                }
            });

            function createConnectionFromData(connData) {
        const fromBlock = document.querySelector(`.block[data-url="${connData.from}"]`);
        const toBlock = document.querySelector(`.block[data-url="${connData.to}"]`);

        if (fromBlock && toBlock) {
            const fromPoint = fromBlock.querySelector(`.connection-point.${connData.fromPoint}`);
            const toPoint = toBlock.querySelector(`.connection-point.${connData.toPoint}`);

            if (fromPoint && toPoint) {
                createConnection(fromPoint, toPoint);
            }
        }
    }

    function makeBlockDraggable(block) {
        let isDragging = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;

        block.addEventListener('mousedown', dragStart);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', dragEnd);

        function dragStart(e) {
            if (e.target.classList.contains('connection-point')) return;

            initialX = e.clientX - block.offsetLeft;
            initialY = e.clientY - block.offsetTop;

            if (e.target === block || block.contains(e.target)) {
                isDragging = true;
            }
        }

        function drag(e) {
            if (!isDragging) return;

            e.preventDefault();
            currentX = e.clientX - initialX;
            currentY = e.clientY - initialY;

            block.style.left = `${currentX}px`;
            block.style.top = `${currentY}px`;

            // Update connections
            updateConnections();
        }

        function dragEnd(e) {
            initialX = currentX;
            initialY = currentY;
            isDragging = false;
        }
    }
    // Main initialization function
    function initializeSystem() {
        initializeDragAndDrop();
        initializeSVGContainer();
        loadSavedFlows();
        setupFlowListeners();
        setupAddFlowButton();
    }

    // Setup Add Flow button functionality
    function setupAddFlowButton() {
      

        const addFlowButton = document.querySelector('.add-flow-button');
        if (addFlowButton) {
            addFlowButton.addEventListener('click', openModalForFlowName);
        }
    }
    function openModalForFlowName() {
      
        // Display the modal
        const modal = document.getElementById('flowNameModal');
        modal.style.display = 'block';

        // Focus on the input field
        const inputField = document.getElementById('flowNameInput');
        inputField.value = ''; // Clear previous value
        inputField.focus();
    }

    // SVG Container initialization
    function initializeSVGContainer() {
        const canvas = document.getElementById('canvas');
        let svg = document.getElementById('connections');

        if (!svg) {
            svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.id = 'connections';
            svg.style.position = 'absolute';
            svg.style.top = '0';
            svg.style.left = '0';
            svg.style.width = '100%';
            svg.style.height = '100%';
            svg.style.pointerEvents = 'none';

            // Add arrow marker definition
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrowhead');
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '7');
            marker.setAttribute('refX', '9');
            marker.setAttribute('refY', '3.5');
            marker.setAttribute('orient', 'auto');

            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
            polygon.setAttribute('fill', '#2196f3');

            marker.appendChild(polygon);
            defs.appendChild(marker);
            svg.appendChild(defs);

            canvas.appendChild(svg);
        }
    }

    // Function to load saved flows
    function loadSavedFlows() {
        const savedFlows = localStorage.getItem('apiFlowStructures');
        if (savedFlows) {
            flowStructures = JSON.parse(savedFlows);
            updateFlowList();

            const selectedFlow = flowStructures[currentFlowId];
            if (selectedFlow) {
                recreateBlocks(selectedFlow); // Recreate blocks first
                setTimeout(() => recreateConnections(selectedFlow), 0); // Ensure blocks are fully rendered before connections
            }
        }
    }

    // Function to update the flow list UI
    function updateFlowList() {
        const container = document.getElementById('flowListContainer');
        if (!container) return;

        // Update visual selection
        const flowItems = container.getElementsByClassName('flow-item');
        for (let item of flowItems) {
            item.style.backgroundColor = '#f5f5f5';
        }

        const selectedFlow = document.getElementById('selectedFlow').value;
        if (selectedFlow) {
            const selectedItem = container.querySelector(`[data-flow-id="${selectedFlow}"]`);
            if (selectedItem) {
                selectedItem.style.backgroundColor = '#e0e0e0';
            }
        }
    }

    function selectFlow(flowId) {


const flowSelectForm = document.getElementById('flowSelectForm');
const flowInput = document.getElementById('selectedFlow');

if (flowSelectForm && flowInput) {
    flowInput.value = flowId;

    // Save the current flow structure before switching
    if (currentFlowId) {
        try {
            const currentFlowStructure = saveFlowStructure();
            flowStructures[currentFlowId] = currentFlowStructure;

            // Persist the updated flowStructures in localStorage
            localStorage.setItem('apiFlowStructures', JSON.stringify(flowStructures));
            console.log(`Saved current flow structure for flow ID: ${currentFlowId}`);
        } catch (error) {
            console.error(`Error saving flow structure for flow ID ${currentFlowId}:`, error);
            alert(`Could not save current flow structure for flow ID ${currentFlowId}.`);
            return;
        }
    }

    // Update the currentFlowId to the selected flow
    currentFlowId = flowId;

    // Submit the form after ensuring the value is set
    requestAnimationFrame(() => {
        try {
            flowSelectForm.submit();
        } catch (error) {
            console.error('Error submitting flow selection form:', error);
            alert('Could not switch flows. Please try again.');
        }
    });
} else {
    alert('Flow selection form or input is missing!');
}
}
    // Update the clearAllData function to properly clean up SVG

            document.addEventListener('DOMContentLoaded', function () {
                initializeDragAndDrop();
            });

            function initializeDragAndDrop() {
                const draggableElements = document.querySelectorAll('.blockelement.draggable');
                const canvas = document.getElementById('canvas');

                draggableElements.forEach(element => {
                    element.addEventListener('dragstart', handleDragStart);
                    element.addEventListener('dragend', handleDragEnd);
                });

                canvas.addEventListener('dragover', (e) => e.preventDefault());
                canvas.addEventListener('drop', handleDrop);
                canvas.addEventListener('click', (e) => {
                    if (e.target === canvas) {
                        clearSelectedPoint();
                    }
                });
            }

           function handleDragStart(e) {
        e.target.classList.add('dragging');
       

        // Set the drag data
        e.dataTransfer.setData('text/plain', JSON.stringify({
            method: e.target.dataset.method,
            url: e.target.dataset.url,
            requestBody: e.target.dataset.requestBody,
            response: e.target.dataset.response,
             parameters: e.target.dataset.parameters,
              device: e.target.dataset.device || null,
                platform: e.target.dataset.platform || null,
                section: e.target.dataset.section || null,
               
        }));

        // Optional: Set a drag image
        const dragImage = e.target.cloneNode(true);
        dragImage.style.position = 'absolute';
        dragImage.style.top = '-1000px';
        document.body.appendChild(dragImage);
        e.dataTransfer.setDragImage(dragImage, 0, 0);
        setTimeout(() => document.body.removeChild(dragImage), 0);
    }


            function handleDragEnd(e) {
                // Remove dragging class
                e.target.classList.remove('dragging');

                // Remove any lingering drag effects from other elements
                document.querySelectorAll('.blockelement').forEach(element => {
                    element.classList.remove('dragging');
                });
            }
// Create a counter in localStorage if it doesn't exist
if (!localStorage.getItem('blockCounter')) {
    localStorage.setItem('blockCounter', '0');
}

// Function to generate a deterministic ID
function generateBlockId(data) {
    // Increment counter
    let counter = parseInt(localStorage.getItem('blockCounter'));
    localStorage.setItem('blockCounter', counter.toString());

    // Create base identifier from existing properties
<!--    const baseId = data.url || `${data.section}-${data.device}-${data.platform}`;-->

    // Combine with counter for uniqueness
    return `${counter}`;
}

function getNextBlockNumber() {
    // Get all blocks on the canvas
    const blocks = document.querySelectorAll('[data-block-id]');
    const numbers = Array.from(blocks).map(block => {
        const blockId = block.getAttribute('data-block-id');
        const match = blockId.match(/\d+$/);
        return match ? parseInt(match[0], 10) : 0;
    });

    // If no blocks exist, start from 1
    if (numbers.length === 0) {
        return 1;
    }

    // Sort numbers to find gaps
    numbers.sort((a, b) => a - b);

    // Find the first gap in the sequence or return next number
    let expectedNumber = 1;
    for (const number of numbers) {
        if (number !== expectedNumber) {
            return expectedNumber;
        }
        expectedNumber++;
    }
    return expectedNumber;
}

function handleDrop(e) {
    e.preventDefault();
    const rawData = e.dataTransfer.getData('text/plain');

    if (!rawData) {
        console.error('No data found in the drop event.');
        return;
    }

    try {
        const data = JSON.parse(rawData);
        const rawSection = data.section;


        const nextBlockNumber = getNextBlockNumber();
        data.id = `${nextBlockNumber}`;

        const storedBlocks = JSON.parse(localStorage.getItem('blockData') || '{}');
        storedBlocks[data.id] = data;
        localStorage.setItem('blockData', JSON.stringify(storedBlocks));
        let draggedElement;
        if (data.url) {
            draggedElement = document.querySelector(`[data-url="${data.url}"]`);
        } else if (data.section) {
            draggedElement = document.querySelector(
                `[data-device="${data.device}"][data-section="${data.section}"][data-platform="${data.platform}"]`
            );
        }

        if (!draggedElement) {
            console.error('Dragged element not found.');
            return;
        }

        if (!data.section) {
            data.section = rawSection;
        }

        const block = createBlock(data, data.id);

        droppedBlocks.add(data.id);
        blockOrder.push(data.id);

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        block.style.left = x + 'px';
        block.style.top = y + 'px';
        block.setAttribute('data-block-id', data.id);

        const positions = JSON.parse(localStorage.getItem('blockPositions') || '{}');
        positions[data.id] = { x, y };
        localStorage.setItem('blockPositions', JSON.stringify(positions));

        canvas.appendChild(block);
        makeBlockInteractive(block);

        block.style.opacity = '0';
        block.style.transform = 'scale(0.95)';
        requestAnimationFrame(() => {
            block.style.transition = 'all 0.2s ease';
            block.style.opacity = '1';
            block.style.transform = 'scale(1)';
        });

        if (typeof saveFlow === 'function') {
            saveFlow();
        }
        updateConnections();

        // Enable Save Flow button
        enableSaveButton();
    } catch (error) {
        console.error('Error handling block drop:', error);
        alert('There was an error adding the block. Please try again.');
    }
}



// Add this function to reorganize block numbers if needed
function reorganizeBlockNumbers() {
    const blocks = Array.from(document.querySelectorAll('[data-block-id]'));
    blocks.sort((a, b) => {
        const aNum = parseInt(a.getAttribute('data-block-id').match(/\d+$/)[0]);
        const bNum = parseInt(b.getAttribute('data-block-id').match(/\d+$/)[0]);
        return aNum - bNum;
    });

    blocks.forEach((block, index) => {
        const newId = `${index + 1}`;
        const oldId = block.getAttribute('data-block-id');
        block.setAttribute('data-block-id', newId);

        // Update any references to this block ID in connections or other data
        updateBlockReferences(oldId, newId);
    });
}

function updateBlockReferences(oldId, newId) {
    // Update stored block data
    const storedBlocks = JSON.parse(localStorage.getItem('blockData') || '{}');
    if (storedBlocks[oldId]) {
        storedBlocks[newId] = storedBlocks[oldId];
        delete storedBlocks[oldId];
        localStorage.setItem('blockData', JSON.stringify(storedBlocks));
    }

    // Update positions
    const positions = JSON.parse(localStorage.getItem('blockPositions') || '{}');
    if (positions[oldId]) {
        positions[newId] = positions[oldId];
        delete positions[oldId];
        localStorage.setItem('blockPositions', JSON.stringify(positions));
    }
}

canvas.removeEventListener('drop', handleDrop);
canvas.addEventListener('drop', handleDrop);

// Function to ensure valid blockCounter handling
function updateBlockCounter() {
    let blockCounter = localStorage.getItem('blockCounter');

    // Ensure blockCounter is a valid number, default to 0 if not
    blockCounter = blockCounter ? parseInt(blockCounter) : 0;

    if (isNaN(blockCounter)) {
        console.error('blockCounter is NaN, initializing to 0');
        blockCounter = 0;  // Initialize to 0 if it's NaN
    }

    // Log the current value of blockCounter to track its changes

    // Increment the blockCounter
    blockCounter++;

    // Save the updated blockCounter to localStorage
    localStorage.setItem('blockCounter', blockCounter);

    // Log the updated value of blockCounter
}


    // Modified removeBlock function to also remove from blockOrder
    function removeBlock(event, url) {

        event.stopPropagation();
        const block = event.target.closest('.block');
        if (block) {
            // Remove any connections associated with this block
            connections = connections.filter(conn =>
                conn.startBlock !== block && conn.endBlock !== block
            );

            // Remove from blockOrder array
            blockOrder = blockOrder.filter(blockUrl => blockUrl !== url);

            // Remove from droppedBlocks Set
            droppedBlocks.delete(url);

            // Remove the block element
            block.remove();

            // Redraw remaining connections
            drawConnections();
        }
    }

    // Function to get block position with error handling
    function getBlockPosition(block) {
        return {
            x: parseInt(block.style.left) || 0,
            y: parseInt(block.style.top) || 0
        };
    }
    // Updated function to get connection points for a block with error handling
    function getBlockConnections(url) {
        const blockConnections = [];
        const block = document.querySelector(`.block[data-url="${url}"]`);

        if (!block) return blockConnections;

        connections.forEach(conn => {
            const startBlock = conn.start.closest('.block');
            const endBlock = conn.end.closest('.block');

            if (startBlock && startBlock.dataset.url === url) {
                blockConnections.push({
                    from: url,
                    to: endBlock.dataset.url,
                    fromPoint: getConnectionPointClassName(conn.start),
                    toPoint: getConnectionPointClassName(conn.end)
                });
            }
        });

        return blockConnections;
    }
   
   function saveFlowStructure() {
   
    const flowDisplayArea = document.getElementById('flowDisplayArea');
    const flowIdFromDisplay = flowDisplayArea.innerHTML;
   
    const flowData = window.FLOW_DATA;
    const modalData = JSON.parse(localStorage.getItem('modalData')) || {};
   
    let networkList = {};
    if ('type' in formData && formData.type === 'network') {
        const divContent = document.getElementById('function-form').innerHTML;
        const storedData = localStorage.getItem('functionData');
        if (storedData) {
            networkList = JSON.parse(storedData);
        }
    }

    const formType = formData.type;
    const flowStructure = {};
    const blocks = document.querySelectorAll('.block');

    blocks.forEach((block, index) => {
        const position = {
            x: block.offsetLeft,
            y: block.offsetTop,
        };
        
        const blockConnections = new Set();
        const connectionPoints = block.querySelectorAll('.connection-point');
        connectionPoints.forEach((point) => {
            connections.forEach((conn) => {
                if (conn.start === point || conn.end === point) {
                    const isStart = conn.start === point;
                    const otherPoint = isStart ? conn.end : conn.start;
                    if (!otherPoint || !otherPoint.closest('.block')) return;
                    
                    const otherBlock = otherPoint.closest('.block');
                    const connectionData = {
                        from: isStart ? block.dataset.blockId : otherBlock.dataset.blockId,
                        to: isStart ? otherBlock.dataset.blockId : block.dataset.blockId,
                        fromPoint: isStart ? point.dataset.pointId : otherPoint.dataset.pointId,
                        toPoint: isStart ? otherPoint.dataset.pointId : point.dataset.pointId
                    };
                    blockConnections.add(JSON.stringify(connectionData));
                }
            });
        });

        const uniqueConnections = Array.from(blockConnections).map((conn) => JSON.parse(conn));
        const blockId = block.dataset.blockId;
        const sectionTitle = block.querySelector('.block-title').textContent.trim();
        let blockDetails = JSON.parse(localStorage.getItem('blockData')) || {};

        if (formType === "network") {
            const network_data = networkList[blockId] || {};
            flowStructure[blockId] = {
                method: network_data.platform || '',
                section: sectionTitle,
                url: network_data.device || '',
                property: network_data || {},
                position: position,
                connections: uniqueConnections,
                order: index,
                blockId: blockId,
                blockDetails: blockDetails[blockId]
            };
        } else {
            // Include modal data for non-network cases
            const requestDetails = JSON.parse(localStorage.getItem('requestDetails')) || {};
            const responseDetails = JSON.parse(localStorage.getItem('responseDetails')) || {};
            
            flowStructure[blockId] = {
                method: block.dataset.method,
                url: block.dataset.url,
                requestBody: block.dataset.requestBody || null,
                response: block.dataset.response || null,
                section: sectionTitle,
                position: position,
                connections: uniqueConnections,
                order: index,
                parameters: block.dataset.parameters || {},
                blockId: blockId,
                property: {
                    requestValues: requestDetails,
                    responseValues: responseDetails
                },
            };
        }
    });
    
    return flowStructure;
}
   
    // Helper function to get connection points class names
    function getConnectionPointClassName(point) {
        return Array.from(point.classList)
            .find(className => className !== 'connection-point') || '';
    }
    // Add resize event listener to update connections when window is resized
    window.addEventListener('resize', debounce(() => {
        updateConnections();
    }, 100));
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

// Reference to the Save Flow button
const saveFlowButton = document.getElementById('saveFlowButton');

// Disable the button initially
saveFlowButton.disabled = true;

// Enable the button when a new block is created
function enableSaveButton() {
    saveFlowButton.disabled = false;
}

// Disable the button after saving
function disableSaveButton() {
    saveFlowButton.disabled = true;
}



function handleSave() {
    const dropdown1 = document.getElementById('dropdown1');
    const dropdown2 = document.getElementById('dropdown2');

    try {
        const flowDisplayArea = document.getElementById('flowDisplayArea');
        const flowIdFromDisplay = flowDisplayArea ? flowDisplayArea.innerHTML.trim() : null;
               
       

// Check if it's truly empty or just visually blank
if (!flowIdFromDisplay || flowIdFromDisplay.length === 0) {
    // No valid flow ID, open the modal to ask for a flow name
    openModalForFlowName();
    return; // Stop further execution until the modal flow name is provided
}


        // Proceed to save the flow structure
        // Proceed to save the flow structure
const flowStructure = saveFlowStructure();

// Initialize the functionData dictionary

let functionData = {};  // Use `let` to allow re-assignment

for (let line in flowStructure) {
    if ('requestBody' in flowStructure[line]) {
        // If 'requestBody' is found, fetch requestDetails and responseDetails
        functionData['requestDetails'] = JSON.parse(localStorage.getItem('requestDetails')) || {};
        functionData['responseDetails'] = JSON.parse(localStorage.getItem('responseDetails')) || {};
        break;  // Exit the loop after the first match
    } else {
        // If 'requestBody' is not found, fetch functionData from localStorage
        functionData = JSON.parse(localStorage.getItem('functionData')) || {};
        break;  // Exit the loop after processing
    }
}




        // Fetch additional data from localStorage

        const blockData = JSON.parse(localStorage.getItem('blockData')) || {};

        // Merge functionData and blockData into flowStructure
        const combinedStructure = {
            ...flowStructure,
            functionData,
            blockData
        };

        // Save to localStorage
        const currentFlowId = flowIdFromDisplay || Object.keys(flowStructures).length + 1;
        flowStructures[currentFlowId] = combinedStructure;

        localStorage.setItem('apiFlowStructures', JSON.stringify(flowStructures));

        // Update hidden input (flowStructureData)
        const flowStructureData = document.getElementById('flowStructureData');
        if (flowStructureData) {
            flowStructureData.value = JSON.stringify({
                flowId: currentFlowId,
                structure: combinedStructure,
                testbed: dropdown1.value,
                scenario: dropdown2.value
                
            });
        }

        // AJAX form submission
        const form = document.getElementById('flowForm');
        if (form) {
            fetch(form.action, {
                method: 'POST',
                body: new FormData(form),
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                },
            })
                .then((response) => response.json())
                .then((data) => {
                    console.log('Flow saved successfully');
                })
                .catch((error) => {
                    console.error('Error saving flow:', error);
                });
        }

        // Show saved feedback
        const saveButton = document.getElementById('saveFlowButton');
        if (saveButton) {
            const originalText = saveButton.innerHTML;

            saveButton.innerHTML = '<i class="fas fa-check"></i> Saved!';
            saveButton.classList.add('saved');
            saveButton.style.color = '#28a745'; // Green color for saved state
            saveButton.disabled = true; // Disable the button after save

            setTimeout(() => {
                saveButton.innerHTML = originalText;
                saveButton.style.color = ''; // Reset to original color
                saveButton.classList.remove('saved');
            }, 2000);
        }

        // Disable button after saving
        disableSaveButton();

        // Update flow list
        updateFlowList();
    } catch (error) {
        console.error('Error saving flow structure:', error);
        alert('Error saving flow structure. Please try again.');
    }
}



        // Add event listener when the document loads
        document.addEventListener('DOMContentLoaded', function() {
            const saveButton = document.getElementById('saveFlowButton');
            if (saveButton) {
                saveButton.addEventListener('click', handleSave);
            }

            // Initialize other necessary components
            initializeSystem();
        });

    function setupAddFlowButton() {
        const addFlowButton = document.querySelector('.add-flow-button');
        if (addFlowButton) {
            addFlowButton.addEventListener('click', openModalForFlowName);
        }
    }

    function openModalForFlowName() {
        // Display the modal
        const modal = document.getElementById('flowNameModal');
        modal.style.display = 'block';

        // Focus on the input field
        const inputField = document.getElementById('flowNameInput');
        inputField.value = ''; // Clear previous value
        inputField.focus();
    }

    function closeModal() {
        const modal = document.getElementById('flowNameModal');
        modal.style.display = 'none';
    }

    function handleFlowNameSubmit() {
        const flowNameInput = document.getElementById('flowNameInput');
        const flowName = flowNameInput.value.trim();

        if (!flowName) {
            alert('Please enter a flow name.');
            return;
        }

        // Close the modal
        closeModal();
        localStorage.clear();
        // Add the new flow
        addNewFlow(flowName);
    }

    function deleteFlow(flowId) {
    // Ask for confirmation before deleting
    if (!confirm(`Are you sure you want to delete the flow "${flowId}"?`)) {
        return;
    }

    // Remove from localStorage
    const storedFlows = JSON.parse(localStorage.getItem('apiFlowStructures')) || {};
    delete storedFlows[flowId];
    localStorage.setItem('apiFlowStructures', JSON.stringify(storedFlows));

    // Remove from window.FLOW_DATA if it exists
    if (window.FLOW_DATA) {
        delete window.FLOW_DATA[flowId];
    }

    // Remove from flowStructures if it exists
    if (typeof flowStructures !== 'undefined') {
        delete flowStructures[flowId];
    }

    // Clear canvas if the deleted flow was the current one
    if (currentFlowId === flowId) {
        clearCanvas();
        currentFlowId = null;
        updateFlowIdDisplay('');
    }

    // Remove the flow item from the UI
    const flowContainer = document.querySelector('.flow-container');
    const flowItem = flowContainer.querySelector(`[data-flow-id="${flowId}"]`).closest('div');
    if (flowItem) {
        flowItem.remove();
    }

    // Update any related UI elements
    updateFlowList();
}
// Modify the existing flow container setup to add delete functionality
function setupFlowContainerListeners() {
    const flowContainer = document.querySelector('.flow-container');
    
    flowContainer.addEventListener('click', function(e) {
        // Handle delete button clicks
        if (e.target.classList.contains('fa-trash')) {
            e.preventDefault();
            e.stopPropagation();
            
            // Get the associated flow ID from the parent container
            const flowItem = e.target.closest('div');
            const flowButton = flowItem.querySelector('.flow-item');
            const flowId = flowButton.getAttribute('data-flow-id');
            
            deleteFlow(flowId);
        }
    });
}

// Update the addNewFlow function to include delete button
function addNewFlow(flowName) {
    clearCanvas();

    const flowContainer = document.querySelector('.flow-container');
    if (!flowContainer) return;

    // Create container div
    const flowItemContainer = document.createElement('div');
    flowItemContainer.style.display = 'flex';
    flowItemContainer.style.justifyContent = 'space-between';
    flowItemContainer.style.alignItems = 'center';
    flowItemContainer.style.padding = '5px 0';

    // Create flow button
    const newFlowButton = document.createElement('button');
    newFlowButton.type = 'submit';
    newFlowButton.className = 'flow-item';
    newFlowButton.setAttribute('data-flow-id', flowName);
    newFlowButton.textContent = flowName;
    newFlowButton.style.flexGrow = '1';
    newFlowButton.style.textAlign = 'left';
    newFlowButton.style.cursor = 'pointer';

    // Create delete icon
    const deleteIcon = document.createElement('i');
    deleteIcon.className = 'fas fa-trash';
    deleteIcon.style.cursor = 'pointer';
    deleteIcon.style.marginLeft = '10px';
    deleteIcon.setAttribute('data-delete-flow-id', flowName); // Set data-delete-flow-id attribute

    // Assemble the elements
    flowItemContainer.appendChild(newFlowButton);
    flowItemContainer.appendChild(deleteIcon);
    flowContainer.appendChild(flowItemContainer);

    // Set up the new flow
    currentFlowId = flowName;
    flowStructures[currentFlowId] = {};
    updateFlowIdDisplay(currentFlowId);
    updateFlowList();

    // Add click event for the flow button
    newFlowButton.addEventListener('click', function (e) {
        e.preventDefault();
        selectFlow(flowName);
    });

    // Add click event for the delete icon
    deleteIcon.addEventListener('click', function (e) {
        e.stopPropagation(); // Prevent triggering the parent button's event
        deleteFlow(flowName);
    });
}
// Call this when the page loads
document.addEventListener('DOMContentLoaded', function() {
    setupFlowContainerListeners();
});
    // Initialize the modal functionality
    document.getElementById('flowNameSubmitButton').addEventListener('click', handleFlowNameSubmit);
    document.getElementById('flowNameCancelButton').addEventListener('click', closeModal);
    window.addEventListener('click', function (event) {
        const modal = document.getElementById('flowNameModal');
        if (event.target === modal) {
            closeModal();
        }
    });



    function clearCanvas() {
        const canvas = document.getElementById('canvas');
        if (canvas) {
            // Clear all child elements inside the canvas
            canvas.innerHTML = '';

            // Reinitialize the SVG container for connections
            initializeSVGContainer();
        }

        // Reset tracking variables
        connections = []; // Clear the global connections array
        droppedBlocks = new Set(); // Reset the dropped blocks set
        blockOrder = []; // Reset the block order array
    }

    // Setup flow management listeners
    function setupFlowListeners() {
          const urlParams = new URLSearchParams(window.location.search);
          const selectedFlow = urlParams.get('selectedFlow');

          if (selectedFlow) {
            loadExistingFlow(selectedFlow);
          }
        }

        // Initialize when document is ready
        document.addEventListener('DOMContentLoaded', setupFlowListeners);

    function clearAllData() {
        blockOrder = [];
        connections = [];
        droppedBlocks.clear();
        const canvas = document.getElementById('canvas');
        while (canvas.firstChild) {
            canvas.removeChild(canvas.firstChild);
        }
        // Clear SVG connections
        const connectionsContainer = document.getElementById('connections');
        if (connectionsContainer) {
            connectionsContainer.innerHTML = '';
        }
    } // Initialize drag and drop when the document is ready
            document.addEventListener('DOMContentLoaded', initializeDragAndDrop);
            let blockDataArray = [];

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
        initializeSVGContainer();
        setupFlowListeners();
    });
            function writeJsonToFile(jsonData, filePath) {
            // Convert the JSON data to a string with 2 spaces for indentation
            const jsonString = JSON.stringify(jsonData, null, 2);


            // Use the Fetch API to send a PUT request to the file path
            fetch(filePath, {
                method: 'PUT',
                headers: {
                'Content-Type': 'application/json'
                },
                body: jsonString
            })
            .then(response => {
                if (response.ok) {
                console.log('JSON data written to file successfully!');
                } else {
                console.error('Error writing JSON data to file:', response.status);
                }
            })
            .catch(error => {
                console.error('Error writing JSON data to file:', error);
            });
            }

    document.addEventListener('DOMContentLoaded', function() {
        const styleElement = document.createElement('style');
        styleElement.textContent = `
            .flow-id-display {
                   color: #666;
        font-style: italic;
        text-align: center;

        margin: 8px 0;
        padding: 14px;
            }
        `;
        document.head.appendChild(styleElement);
    });

    // Function to update or create flow ID display
    function updateFlowIdDisplay(flowId) {
        const canvas = document.getElementById('canvas');
        let flowDisplay = canvas.querySelector('.flow-id-display');

        if (!flowDisplay) {
            flowDisplay = document.createElement('div');
            flowDisplay.className = 'flow-id-display';
            canvas.appendChild(flowDisplay);
        }

        flowDisplay.textContent = `${flowId}`;
        const flowDisplayArea = document.getElementById('flowDisplayArea');
    flowDisplayArea.innerHTML = `${flowId}`;
    }
    // Create block with updated JSON structure
    // Map to store colors for each section
    const sectionColors = {};

    // Set to track already used colors
    const usedColors = new Set();

    // Function to generate random light colors
    function getRandomLightColor() {
        let color;
        do {
            const getLightValue = () => Math.floor(200 + Math.random() * 55); // Values between 200-255
            const r = getLightValue();
            const g = getLightValue();
            const b = getLightValue();
            color = `rgb(${r}, ${g}, ${b})`;
        } while (usedColors.has(color)); // Ensure the color is unique
        usedColors.add(color); // Add to used colors
        return color;
    }
    function highlightBlock(block) {
        // Clear any previous highlight
        const previouslyHighlightedBlock = document.querySelector('.block[style*="box-shadow"]');
        if (previouslyHighlightedBlock && previouslyHighlightedBlock !== block) {
            previouslyHighlightedBlock.style.boxShadow = '';
        }
        // Highlight the new block
        block.style.boxShadow = '0 0 10px rgba(0, 150, 255, 0.7)';
    }

    // Function to toggle modal visibility
//     window.toggleModal = function() {
//     const modalContainer = document.getElementById('result-modal');
//     modalContainer.classList.toggle('hidden');

//     if (!modalContainer.classList.contains('hidden')) {
//         centerModal(); // Center when showing
//     } else {
//         // Remove box shadow from the highlighted block
//         const highlightedBlock = document.querySelector('.block[style*="box-shadow"]');
//         if (highlightedBlock) {
//             highlightedBlock.style.boxShadow = '';
//         }
//     }
// };



function createBlock(data) {
    const template = document.getElementById('block-template');
    const block = template.content.cloneNode(true).firstElementChild;
    block.dataset.blockId = data.id;

    if (data.method) {
        block.dataset.method = data.method;
        block.dataset.url = data.url;
        block.dataset.requestBody = data.requestBody || 'N/A';
        block.dataset.response = data.response || 'N/A';
        block.dataset.parameters = data.parameters || 'N/A';
    } else {
        block.dataset.platform = data.platform || data.method || '';
        block.dataset.device = data.device || data.url || '';
    }

    // Important: Use the section from the data, fallback to 'default' only if undefined
    const section = data.section !== undefined && data.section !== null ? data.section : 'default';
    block.dataset.section = section;

    const blockTitleElement = block.querySelector('.block-title');
    blockTitleElement.textContent = section; // Set the title directly from the section

    // Apply section colors
    if (!sectionColors[section]) {
        sectionColors[section] = getRandomLightColor();
    }
    const sectionColor = sectionColors[section];
    block.style.borderColor = sectionColor;
    block.querySelector('.block-header').style.backgroundColor = sectionColor;

    // Set block number
    const blockIdElement = block.querySelector('.block-num');
    blockIdElement.textContent = data.id;

    // Set method badge
    const methodBadge = block.querySelector('.method-badge');
   if (data.method) {
    methodBadge.textContent = data.method;
    methodBadge.className = `method-badge method-${data.method.toLowerCase()}`;
    block.querySelector('.url-input').value = data.url;
} else {
  
    let displayText = '';

    // Check savedFlow.device first, then fallback to localStorage or other options
    if (data.device) {
        displayText = `${data.platform || ''} - ${data.device}`;
    } else if (data.blockDetails && data.blockDetails.device) {
        displayText = `${data.blockDetails.platform || ''} - ${data.blockDetails.device}`;
    } else {
        displayText = 'Unknown'; // Fallback text for undefined cases
    }

    methodBadge.textContent = displayText;
    methodBadge.className = 'method-badge method-platform-device';
}


    // Set up buttons and connection points (rest of the function remains the same)
    block.querySelector('.edit-button').onclick = () => {
        const request  = JSON.parse(localStorage.getItem('requestDetails')) || {};
    const response = JSON.parse(localStorage.getItem('responseDetails')) || {};
    const blockElement = event?.target?.closest('.block');
    const blockNum = blockElement?.querySelector('.block-num')?.textContent;
        highlightBlock(block);
     
        if (!request[blockNum] && !response[blockNum]) {

    // If both request and response are not available
    showDetails(block);
} else if (request[blockNum] && response[blockNum]) {
    // If both request and response are available
    showDetails(block, request[blockNum], response[blockNum]);
} else {
    // Handle cases where only one of them is available
    if (request[blockNum]) {
        showDetails(block, request[blockNum], response[blockNum] = null);
    }
    if (response[blockNum]) {

        showDetails(block,request[blockNum] = null, response[blockNum]);
    }
}


       
    };
    block.querySelector('.delete-button').onclick = (e) =>
        removeBlock(e, data.url || data.device || data.id);

    const connectionPoints = block.querySelectorAll('.connection-point');
    connectionPoints.forEach((point, index) => {
        const pointId = `${data.id}-point-${index}`;
        point.dataset.pointId = pointId;

        point.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            handleConnectionPointClick(e, point);
        });
        point.addEventListener('mouseenter', () => {
            if (selectedPoint && selectedPoint !== point) {
                point.classList.add('potential-target');
            }
        });
        point.addEventListener('mouseleave', () => {
            point.classList.remove('potential-target');
        });
    });

    return block;
}

function handleConnectionPointClick(event, point) {
    event.stopPropagation();
 
    if (!selectedPoint) {
        // First point selection
        selectedPoint = point;
        point.classList.add('active');
        document.addEventListener('mousemove', handleConnectionDrag);
    } else if (selectedPoint !== point) {
        // Second point selection
        const startBlock = selectedPoint.closest('.block');
        const endBlock = point.closest('.block');
 
        if (startBlock && endBlock && startBlock !== endBlock && !connectionExists(selectedPoint, point)) {
            createConnection(selectedPoint, point);
        }
 
        // Clean up
        selectedPoint.classList.remove('active');
        point.classList.remove('potential-target');
        selectedPoint = null;
        document.removeEventListener('mousemove', handleConnectionDrag);
 
        // Remove temporary path if it exists
        const tempPath = document.getElementById('temp-path');
        if (tempPath) {
            tempPath.remove();
        }
    }
}
function handleConnectionDrag(event) {
    if (!selectedPoint || !tempPath) return;

    const svg = document.getElementById('connections');
    const svgRect = svg.getBoundingClientRect();
    
    // Get start point coordinates
    const startRect = selectedPoint.getBoundingClientRect();
    const startX = startRect.left + startRect.width / 2 - svgRect.left;
    const startY = startRect.top + startRect.height / 2 - svgRect.top;
    
    // Get end point coordinates (mouse position relative to SVG)
    const endX = event.clientX - svgRect.left;
    const endY = event.clientY - svgRect.top;

    // Create the path
    const d = `M ${startX} ${startY} L ${endX} ${endY}`;
    tempPath.setAttribute('d', d);
}
            // Function to fetch recursive HTML for rendering JSON schema
            async function fetchRecursiveHtml(jsonData, parentPath) {
                const response = await fetch(
                    `/render-json-recursive/?json_data=${encodeURIComponent(JSON.stringify(jsonData))}&parent_path=${encodeURIComponent(parentPath)}`
                );
                const data = await response.json();
                return data.html; // Response will contain rendered HTML for json_render_recursive.html
            }

            // Function to fetch HTML for individual fields
            async function fetchFieldHtml(key, prop, prefix) {
                const response = await fetch(`/render-field/?key=${encodeURIComponent(key)}&prop=${encodeURIComponent(JSON.stringify(prop))}&prefix=${encodeURIComponent(prefix)}`);
                const data = await response.json();
                return data.html; // The response will contain rendered HTML for field_render.html
            }

            // Function to generate form fields based on schema type and structure
            async function generateFormFields(schema) {
                let valuesHtml = ''; // Store the generated HTML for the fields

                // Helper function to render a single field
                async function renderField(key, prop, prefix) {
                    const fieldHtml = await fetchFieldHtml(key, prop, prefix);
                    valuesHtml += fieldHtml; // Append each field's HTML to the container
                }

                // Handle different schema types
                if (schema.type === 'array' && schema.items && schema.items.type === 'object') {
                    // For arrays of objects
                    for (const [key, prop] of Object.entries(schema.items.properties)) {
                        await renderField(key, prop, 'API-DATA');
                    }
                } else if (schema.type === 'object' && schema.properties) {
                    // For objects with properties
                    for (const [key, prop] of Object.entries(schema.properties)) {
                        await renderField(key, prop, 'API-DATA');
                    }
                } else {
                    // Fallback for unsupported schemas
                    valuesHtml += '<p>No fields available for this API.</p>';
                }

                return valuesHtml; // Return the generated HTML for all fields
            }
            function escapeForHtmlAttribute(json) {
               return JSON.stringify(json)
                .replace(/&/g, '&amp;') // Escape &
                .replace(/</g, '&lt;')  // Escape <
                .replace(/>/g, '&gt;')  // Escape >
                .replace(/'/g, '&#39;') // Escape single quotes
                .replace(/"/g, '&quot;'); // Escape double quotes
            }


            // Updated showDetails function
            async function showDetails(button, storedRequest = null, storedResponse = null) {
    
    const block = button.closest('.block');
    if (block) {
        // Retrieve the dataset attributes
        const blockId = block.dataset.blockId; // Gets 'data-block-id'
        const url = block.dataset.url;         // Gets 'data-url'
        const section = block.dataset.section; // Gets 'data-section'
    }

    block.style.boxShadow = '0 0 10px 3px rgba(255, 0, 0, 0.5)';
    // Activate the selected tab (uses your existing activateTab function)
    activateTab(document.querySelector(`[data-tab="request"]`));

    // Get containers
    const requestContainer = document.getElementById('request');
    const responseContainer = document.getElementById('response');

    // Show loading state
    requestContainer.innerHTML = '<div class="loading">Loading request details...</div>';
    responseContainer.innerHTML = '<div class="loading">Loading response details...</div>';

    // Handle Request Tab Content
    try {
        const jsonString = block.dataset.requestBody
            .replace(/'/g, '"')
            .replace(/\bTrue\b/g, 'true')
            .replace(/\bFalse\b/g, 'false')
            .replace(/\bN\/A\b/g, 'null')
            .replace(/\bNone\b/g, 'null');

        const requestSchema = JSON.parse(jsonString);

        const generatedRequestHtml = await generateFormFields(requestSchema.content?.['application/json']?.schema || {});
        let displayhtml = generatedRequestHtml;

        if (storedRequest) {
            const tempContainer = document.createElement('div');
            tempContainer.innerHTML = generatedRequestHtml;


            Object.entries(storedRequest).forEach(([key, value]) => {
                const input = tempContainer.querySelector(`[name="API-DATA['${key}']"]`);

                if (input) {

                    if (input.tagName === 'INPUT' || input.tagName === 'TEXTAREA') {
                        input.value = value;
                        input.setAttribute('value', value);
                        input.dispatchEvent(new Event('input', { bubbles: true }));

                    } else if (input.tagName === 'SELECT') {
                        input.value = value;
                        Array.from(input.options).forEach(option => {
                            if (option.value === value) {
                                option.selected = true;
                            }
                        });
                        input.dispatchEvent(new Event('change', { bubbles: true }));

                    }
                } else {
                    console.warn(`No input found for key: ${key}`);
                }
            });

            displayhtml = tempContainer.innerHTML;
        }

        requestContainer.innerHTML = `
            <div class="form-container" style="overflow-y: auto; max-height: 20rem; min-height: 20rem; ">
                <form action="{% url 'testscenario:submit_edits' %}" method="post" id="valuesForm" enctype="multipart/form-data">
                    {% csrf_token %}
                    <div id="valuesFormFields">
                        ${displayhtml}
                    </div>
                    <button type="submit" class="btn-primary" id="submitValuesBtn">
                        <i class="fa fa-save"></i> Submit Values
                    </button>
                </form>
            </div>
        `;

        const restructureFormData = (formData) => {
            const result = {};
            for (const [key, value] of formData.entries()) {
                const cleanKey = key.replace(/^API-DATA\['|'\]/g, '').replace(/\['/g, '.').replace(/'\]/g, '');
                const keys = cleanKey.split('.');

                let current = result;
                keys.forEach((k, index) => {
                    if (index === keys.length - 1) {
                        current[k] = value;
                    } else {
                        current[k] = current[k] || {};
                        current = current[k];
                    }
                });
            }

            return result;
        };

        valuesForm.addEventListener('submit', function (event) {
            event.preventDefault();

            const formData = new FormData(valuesForm);
            const structuredData = restructureFormData(formData);

            structuredData.blockId = block.dataset.blockId;
            structuredData.url = block.dataset.url;
            structuredData.section = block.dataset.section;

            const existingData = JSON.parse(localStorage.getItem('requestDetails')) || {};
            existingData[structuredData.blockId] = structuredData;

            localStorage.setItem('requestDetails', JSON.stringify(existingData, null, 2));

        });
    } catch (error) {
        console.error("Invalid JSON format in requestBody:", error);
        requestContainer.innerHTML = `
            <div class="error-message">
                <i class="fa fa-exclamation-circle"></i>
                Error: Invalid JSON format in requestBody.
            </div>
        `;
    }

    // Handle Response Tab Content
    try {
    let responseJsonString = block.dataset.response;
    responseJsonString = responseJsonString
        .replace(/'/g, '"')
        .replace(/\bTrue\b/g, 'true')
        .replace(/\bFalse\b/g, 'false')
        .replace(/\bNone\b/g, 'null');

    const responseParsed = JSON.parse(responseJsonString);
    const status200Details = responseParsed['200'] || {};
    const schema = status200Details.content?.['application/json']?.schema || {};

    const recursiveHtml = await fetchRecursiveHtml(schema, '');
    let displayresponsehtml = recursiveHtml;

    const check_list = ['API-Comparison---', 'API-Expected---'];
    
    if (storedResponse) {
        // Create a temporary table to preserve structure
        const tempTable = document.createElement('table');
        tempTable.innerHTML = `<tbody>${recursiveHtml}</tbody>`;
        // Process the stored response
        for (let i of check_list) {
    let search_key = storedResponse[i];
    let name_key = `${i}`;
    // Normalize the structure - handle both cases (with/without items)
    if ('items' in storedResponse[i]) {
        search_key = storedResponse[i].items;
        name_key = `${i}['items']`;
    }
    // Check if properties exist and is an object
    if (search_key?.properties && typeof search_key.properties === 'object') {
        
        Object.entries(search_key.properties).forEach(([key, value]) => {
            const nameSelector = `${name_key}['properties']['${key}']`;
            const input = tempTable.querySelector(`[name="${CSS.escape(nameSelector)}"]`);
            
            if (input) {
                if (input.tagName === 'INPUT' || input.tagName === 'TEXTAREA') {
                    input.value = value;
                    input.setAttribute('value', value);
                } else if (input.tagName === 'SELECT') {
                    input.value = value;
                    Array.from(input.options).forEach(option => {
                        if (option.value === value) {
                            option.selected = true;
                        }
                    });
                }
                input.dispatchEvent(new Event('input', { bubbles: true }));
            }
        });
    }
}

        displayresponsehtml = tempTable.querySelector('tbody').innerHTML;
    }

    // Initial render
    responseContainer.innerHTML = `
        <div class="form-container" style="overflow-y: auto; max-height: 20rem; min-height: 20rem; font-size: 12px;">
            <form action="{% url 'testscenario:submit_validation' %}" method="post" id="validateForm">
                {% csrf_token %}
                <table class="table table-bordered">
                    <thead>
                        <tr>
                            <th>Key</th>
                            <th>Comparison Operator</th>
                            <th>Expected Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${displayresponsehtml}
                    </tbody>
                </table>
                <button type="submit" class="btn btn-primary mt-3" id="submitValidationBtn">Validate</button>
            </form>
        </div>
    `;

    // Get form reference
    const validateForm = document.getElementById('validateForm');
    
    validateForm.addEventListener('submit', async function (event) {
        event.preventDefault();
        
        // Collect current form values before any modifications
        const formValues = {};
        const inputs = validateForm.querySelectorAll('input, select, textarea');
        inputs.forEach(input => {
            formValues[input.name] = input.value;
        });
        
        const formData = new FormData(this);
        const structuredData = restructureFormData(formData);
        
        structuredData.blockId = block.dataset.blockId;
        structuredData.url = block.dataset.url;
        structuredData.section = block.dataset.section;
        
        // Store the data
        const existingData = JSON.parse(localStorage.getItem('responseDetails')) || {};
        existingData[structuredData.blockId] = structuredData;
        localStorage.setItem('responseDetails', JSON.stringify(existingData, null, 2));
        
        // Get current table structure
        const tableBody = validateForm.querySelector('tbody');
        const currentHtml = tableBody.innerHTML;
        
        // Create temporary table for structure preservation
        const tempTable = document.createElement('table');
        tempTable.innerHTML = `<tbody>${currentHtml}</tbody>`;
        
        // Restore all input values while maintaining structure
        Object.entries(formValues).forEach(([name, value]) => {
            const input = tempTable.querySelector(`[name="${CSS.escape(name)}"]`);
            if (input) {
                input.value = value;
                input.setAttribute('value', value);
            }
        });
        
        // Update the table body while maintaining both structure and values
        tableBody.innerHTML = tempTable.querySelector('tbody').innerHTML;
        
        // Restore values after DOM update
        Object.entries(formValues).forEach(([name, value]) => {
            const input = tableBody.querySelector(`[name="${CSS.escape(name)}"]`);
            if (input) {
                input.value = value;
                input.setAttribute('value', value);
                input.dispatchEvent(new Event('input', { bubbles: true }));
            }
        });
    });

} catch (error) {
    console.error("Error in response processing:", error);
    responseContainer.innerHTML = `
        <div class="error-message">
            <i class="fa fa-exclamation-circle"></i>
            Error: Invalid JSON format in response.
        </div>
    `;
}
const restructureFormData = (formData) => {
            const result = {};
            for (const [key, value] of formData.entries()) {
                const cleanKey = key.replace(/^API-DATA\['|'\]/g, '').replace(/\['/g, '.').replace(/'\]/g, '');
                const keys = cleanKey.split('.');

                let current = result;
                keys.forEach((k, index) => {
                    if (index === keys.length - 1) {
                        current[k] = value;
                    } else {
                        current[k] = current[k] || {};
                        current = current[k];
                    }
                });
            }

            return result;
        };
}

           // Add this after generating the form in `requestContainer.innerHTML`
document.getElementById('valuesForm').addEventListener('submit', (event) => {
    event.preventDefault(); // Prevent the default form submission

    // Get the form element
    const form = event.target;

    // Create a FormData object to extract all input values
    const formData = new FormData(form);

    // Convert FormData to an object for easier inspection
    const formValues = {};
    formData.forEach((value, key) => {
        formValues[key] = value;
    });

   
});

            // Tab switching functionality
            document.addEventListener('DOMContentLoaded', function () {
                const tabButtons = document.querySelectorAll('.tab-button');

                tabButtons.forEach(button => {
                    button.addEventListener('click', (e) => {
                        activateTab(button);
                    });
                });
            });

            

            // Function to activate a tab
            function activateTab(selectedTab) {
                // Remove active class from all tabs and panes
                document.querySelectorAll('.tab-button').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelectorAll('.tab-pane').forEach(pane => {
                    pane.classList.remove('active');
                });

                // Add active class to selected tab and its content
                selectedTab.classList.add('active');
                const targetId = selectedTab.dataset.tab;
                document.getElementById(targetId).classList.add('active');
            }
    function removeEditHighlight(block) {
        block.style.boxShadow = 'none';
    }
        function handlePointClick(point) {
            alert('hii');
                if (selectedPoint === point) {
                    clearSelectedPoint();
                    return;
                }

                if (selectedPoint) {
                    createConnection(selectedPoint, point);
                    clearSelectedPoint();
                } else {
                    if (selectedPoint) {
                        selectedPoint.classList.remove('active');
                    }
                    selectedPoint = point;
                    point.classList.add('active');
                }
            }
//             function createConnection(startPoint, endPoint) {
//                 console.log("crete connection");
//     const svg = document.getElementById('connections');
//     if (!svg) {
//         console.error('SVG container not found');
//         return;
//     }

//     const canvasRect = document.getElementById('canvas').getBoundingClientRect();
//     const startRect = startPoint.getBoundingClientRect();
//     const endRect = endPoint.getBoundingClientRect();

//     const startX = startRect.left + startRect.width / 2 - canvasRect.left;
//     const startY = startRect.top + startRect.height / 2 - canvasRect.top;
//     const endX = endRect.left + endRect.width / 2 - canvasRect.left;
//     const endY = endRect.top + endRect.height / 2 - canvasRect.top;

//     const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
//     path.setAttribute('d', `M${startX},${startY} C${startX + 50},${startY} ${endX - 50},${endY} ${endX},${endY}`);
//     path.setAttribute('stroke', '#2196f3');
//     path.setAttribute('stroke-width', '1');
//     path.setAttribute('fill', 'none');
//     path.setAttribute('marker-end', 'url(#arrowhead)');

//     // Generate unique connection ID
//     const connectionId = `conn-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
//     path.setAttribute('data-connection-id', connectionId);

//     // Store connection data immediately
//     const connectionData = {
//         start: startPoint,
//         end: endPoint,
//         path: path,
//         id: connectionId,
//         fromBlockId: startPoint.closest('.block').dataset.blockId,
//         toBlockId: endPoint.closest('.block').dataset.blockId,
//         fromPointId: startPoint.dataset.pointId,
//         toPointId: endPoint.dataset.pointId
//     };
    
//     connections.push(connectionData);

//     // Simple remove function
//     function removeThisConnection() {
//         const index = connections.findIndex(conn => conn.id === connectionId);
//         if (index !== -1) {
//             connections.splice(index, 1);
//             path.remove();
//             if (typeof saveFlow === 'function') {
//                 saveFlow();
//             }
//         }
//     }

//     // Add click handler directly
//     path.onclick = (e) => {
//         e.stopPropagation();
//         removeThisConnection();
//     };

//     // Hover effects
//     path.onmouseenter = () => {
//         path.setAttribute('stroke', 'red');
//         path.style.cursor = 'pointer';
//     };

//     path.onmouseleave = () => {
//         path.setAttribute('stroke', '#2196f3');
//     };

//     svg.appendChild(path);
    
//     // Save flow after creating connection
//     if (typeof saveFlow === 'function') {
//         saveFlow();
//     }

//     return connectionData;
// }
function createConnection(fromPoint, toPoint) {
 
        if (!fromPoint || !toPoint) return;
 
        const connection = {
            start: fromPoint,
            end: toPoint,
            path: document.createElementNS('http://www.w3.org/2000/svg', 'path'),
 
        };
 
        connection.path.setAttribute('class', 'connection-line animated-connection');
        connection.path.setAttribute('marker-end', 'url(#arrowhead)');
 
        // Add click handler for removal
        connection.path.addEventListener('click', (e) => {
            e.stopPropagation();
            removeConnection(connection);
        });
 
        // Add hover effects
        connection.path.addEventListener('mouseenter', (e) => {
            connection.path.style.strokeWidth = '2';
            showConnectionTooltip(e, 'Click to remove connection');
        });
 
        connection.path.addEventListener('mouseleave', () => {
            connection.path.style.strokeWidth = '1';
            hideConnectionTooltip();
        });
 
        const svg = document.getElementById('connections');
        svg.appendChild(connection.path);
        connections.push(connection);
        updateConnections();
 
        // Store connection data for the flow
        const startBlock = start.closest('.block');
        const endBlock = end.closest('.block');
 
        if (startBlock && endBlock) {
            const connectionData = {
                from: startBlock.dataset.url,
                to: endBlock.dataset.url,
                fromPoint: connection.fromPoint,
                toPoint: connection.toPoint
            };
        }
    }

    function createConnection(fromPoint, toPoint) {
 
        if (!fromPoint || !toPoint) return;
 
        const connection = {
            start: fromPoint,
            end: toPoint,
            path: document.createElementNS('http://www.w3.org/2000/svg', 'path'),
 
        };
 
        connection.path.setAttribute('class', 'connection-line animated-connection');
        connection.path.setAttribute('marker-end', 'url(#arrowhead)');
 
        // Add click handler for removal
        connection.path.addEventListener('click', (e) => {
            e.stopPropagation();
            removeConnection(connection);
        });
 
        // Add hover effects
        connection.path.addEventListener('mouseenter', (e) => {
            connection.path.style.strokeWidth = '2';
            showConnectionTooltip(e, 'Click to remove connection');
        });
 
        connection.path.addEventListener('mouseleave', () => {
            connection.path.style.strokeWidth = '1';
            hideConnectionTooltip();
        });
 
        const svg = document.getElementById('connections');
        svg.appendChild(connection.path);
        connections.push(connection);
        updateConnections();
 
        // Store connection data for the flow
        const startBlock = start.closest('.block');
        const endBlock = end.closest('.block');
 
        if (startBlock && endBlock) {
            const connectionData = {
                from: startBlock.dataset.url,
                to: endBlock.dataset.url,
                fromPoint: connection.fromPoint,
                toPoint: connection.toPoint
            };
        }
    }


    function removeConnection(startPoint, endPoint, path) {
    // Remove the path element from SVG
    path.remove();

    // Remove the connection from our connections array
    connections = connections.filter(conn => {
        const isMatch = (
            (conn.start === startPoint && conn.end === endPoint) ||
            (conn.start === endPoint && conn.end === startPoint)
        );
        return !isMatch;
    });

    // Remove any temporary drawing elements
    const tempPath = document.getElementById('temp-path');
    if (tempPath) {
        tempPath.remove();
    }

    // Reset any active points
    if (selectedPoint) {
        selectedPoint.classList.remove('active');
        selectedPoint = null;
    }

    // Remove any potential target highlights
    document.querySelectorAll('.potential-target').forEach(point => {
        point.classList.remove('potential-target');
    });

    // Update the connections if needed
    updateConnections();
}
            function updateConnectionPosition(line, startPoint, endPoint) {
        const svg = document.getElementById('connections');
        const svgRect = svg.getBoundingClientRect();
        const canvasRect = document.getElementById('canvas').getBoundingClientRect();

        // Get the center positions of the connection points
        const startRect = startPoint.getBoundingClientRect();
        const endRect = endPoint.getBoundingClientRect();

        // Calculate positions relative to the SVG container
        const startX = startRect.left + (startRect.width / 2) - canvasRect.left;
        const startY = startRect.top + (startRect.height / 2) - canvasRect.top;
        const endX = endRect.left + (endRect.width / 2) - canvasRect.left;
        const endY = endRect.top + (endRect.height / 2) - canvasRect.top;

        // Update line coordinates
        line.setAttribute('x1', startX);
        line.setAttribute('y1', startY);
        line.setAttribute('x2', endX);
        line.setAttribute('y2', endY);
    }
    function connectionExists(startPoint, endPoint) {
    return connections.some(conn => 
        (conn.start === startPoint && conn.end === endPoint) || 
        (conn.start === endPoint && conn.end === startPoint)
    );
}

 
  
    function hideConnectionTooltip() {
        const tooltip = document.querySelector('.connection-tooltip');
        if (tooltip) {
            tooltip.style.display = 'none';
        }
    }

            // Update the SVG element to enable pointer events
            document.addEventListener('DOMContentLoaded', function () {
                const svg = document.getElementById('connections');
                svg.style.pointerEvents = 'all';
            });

            // Update removeBlock function to also remove associated connections
            function removeBlock(event, url) {
                event.stopPropagation();
                const block = event.target.closest('.block');

                // Get all connection points of the block
                const points = block.querySelectorAll('.connection-point');

                // Remove all connections associated with this block
                connections = connections.filter(conn => {
                    if (Array.from(points).includes(conn.start) || Array.from(points).includes(conn.end)) {
                        conn.path.remove();
                        return false;
                    }
                    return true;
                });

                droppedBlocks.delete(url);
                block.remove();
            }

            // Update clearSelectedPoint to also clear when clicking on canvas
            function clearSelectedPoint() {
                if (selectedPoint) {
                    selectedPoint.classList.remove('active');
                    selectedPoint = null;
                }
            }

            // Add canvas click handler to clear selected point
            document.addEventListener('DOMContentLoaded', function () {
                const canvas = document.getElementById('canvas');
                canvas.addEventListener('click', (e) => {
                    if (e.target === canvas) {
                        clearSelectedPoint();
                    }
                });
            });
            function generatePath(start, end) {
                // Calculate the direction of the connection
                const startPoint = start.point;
                const endPoint = end.point;

                let startX = start.x;
                let startY = start.y;
                let endX = end.x;
                let endY = end.y;

                // Adjust control points based on connection point positions
                let controlPoint1X, controlPoint1Y, controlPoint2X, controlPoint2Y;

                const offset = 50; // Control point offset

                if (startPoint.classList.contains('right')) {
                    controlPoint1X = startX + offset;
                    controlPoint1Y = startY;
                } else if (startPoint.classList.contains('left')) {
                    controlPoint1X = startX - offset;
                    controlPoint1Y = startY;
                } else if (startPoint.classList.contains('top')) {
                    controlPoint1X = startX;
                    controlPoint1Y = startY - offset;
                } else { // bottom
                    controlPoint1X = startX;
                    controlPoint1Y = startY + offset;
                }

                if (endPoint.classList.contains('right')) {
                    controlPoint2X = endX + offset;
                    controlPoint2Y = endY;
                } else if (endPoint.classList.contains('left')) {
                    controlPoint2X = endX - offset;
                    controlPoint2Y = endY;
                } else if (endPoint.classList.contains('top')) {
                    controlPoint2X = endX;
                    controlPoint2Y = endY - offset;
                } else { // bottom
                    controlPoint2X = endX;
                    controlPoint2Y = endY + offset;
                }

                // Create a curved path using cubic Bezier
                return `M ${startX},${startY}
                        C ${controlPoint1X},${controlPoint1Y}
                          ${controlPoint2X},${controlPoint2Y}
                          ${endX},${endY}`;
            }
            function updateConnections() {
        connections.forEach(conn => {
            const startRect = conn.start.getBoundingClientRect();
            const endRect = conn.end.getBoundingClientRect();
            const canvasRect = document.getElementById('canvas').getBoundingClientRect();

            const start = {
                x: startRect.left + startRect.width / 2 - canvasRect.left,
                y: startRect.top + startRect.height / 2 - canvasRect.top,
                point: conn.start
            };
            const end = {
                x: endRect.left + endRect.width / 2 - canvasRect.left,
                y: endRect.top + endRect.height / 2 - canvasRect.top,
                point: conn.end
            };

            const path = generatePath(start, end);
            conn.path.setAttribute('d', path);

            // Add hover effect
            conn.path.addEventListener('mouseenter', (e) => {
                conn.path.setAttribute('stroke', 'red'); // Change color on hover
                conn.path.setAttribute('stroke-width', '2'); // Increase stroke width on hover
                showConnectionTooltip(e, 'Click to remove connection');
            });

            conn.path.addEventListener('mouseleave', () => {
                conn.path.setAttribute('stroke', '#2196f3'); // Reset to default color
                conn.path.setAttribute('stroke-width', '1'); // Reset to default stroke width
                hideConnectionTooltip(); // Ensure the tooltip is hidden
            });

            // Add click functionality to remove the connection
            conn.path.addEventListener('click', () => {
                conn.path.remove(); // Remove the path from the DOM
                connections = connections.filter(c => c !== conn); // Remove from connections array
                hideConnectionTooltip(); // Hide tooltip if connection is removed
            });
        });
    }
    // Initialize connection points
    function makeBlockInteractive(block) {
        let isDragging = false;
        let startX, startY, originalX, originalY;

        block.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('connection-point') ||
                e.target.classList.contains('delete-button') ||
                e.target.classList.contains('edit-button')) {
                return;
            }

            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            originalX = block.offsetLeft;
            originalY = block.offsetTop;
            block.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const dx = e.clientX - startX;
            const dy = e.clientY - startY;

            block.style.left = `${originalX + dx}px`;
            block.style.top = `${originalY + dy}px`;

            updateConnections();
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            block.style.cursor = 'grab';
        });

        // Set up connection points
        const points = block.querySelectorAll('.connection-point');
        points.forEach(point => {
            point.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                handleConnectionPointClick(e, point);
            });
        });
    }
            // Update marker style for the arrow
            document.querySelector('#arrowhead polygon').setAttribute('fill', '#2196f3');

            function clearSelectedPoint() {
                if (selectedPoint) {
                    selectedPoint.classList.remove('active');
                    selectedPoint = null;
                }
            }

            function getBlockTitle(method) {
                switch (method) {
                    case 'GET': return 'Get All Users';
                    case 'POST': return 'Add User';
                    case 'DELETE': return 'Delete User';
                    default: return 'Unknown Action';
                }
            }

            document.getElementById('searchInput').addEventListener('keypress', function (event) {
                if (event.key === 'Enter') {
                    performSearch();
                }
            });

            function performSearch() {
                const searchInput = document.getElementById('searchInput');
                const searchTerm = searchInput.value.toLowerCase().trim();

                // Remove previous highlights
                document.querySelectorAll('.highlight').forEach(el => {
                    el.classList.remove('highlight');
                });

                // If search is empty, collapse all sections and return
                if (!searchTerm) {
                    document.querySelectorAll('.url-list').forEach(list => {
                        list.style.display = 'none';
                    });
                    document.querySelectorAll('.toggle-button').forEach(button => {
                        button.textContent = '▼';
                    });
                    return;
                }

                // Reset all URL lists display
                document.querySelectorAll('.url-list').forEach(list => {
                    list.style.display = 'none';
                });

                // Get all block headings and URLs
                const blockHeadings = document.querySelectorAll('.block-heading');

                let foundMatch = false;

                blockHeadings.forEach(heading => {
                    const sectionTitle = heading.querySelector('h4').textContent.toLowerCase();
                    const urlList = heading.nextElementSibling;
                    const urls = urlList.querySelectorAll('.blockelement');

                    let sectionMatch = false;

                    // Check section title
                    if (sectionTitle.includes(searchTerm)) {
                        heading.classList.add('highlight');
                        sectionMatch = true;
                        foundMatch = true;
                    }

                    // Check URLs in this section
                    urls.forEach(element => {
                        const method = element.getAttribute('data-method').toLowerCase();
                        const url = element.getAttribute('data-url').toLowerCase();

                        if (method.includes(searchTerm) || url.includes(searchTerm)) {
                            sectionMatch = true;
                            foundMatch = true;
                        }
                    });

                    // Show section if there's a match
                    if (sectionMatch) {
                        urlList.style.display = 'block';
                        heading.querySelector('.toggle-button').textContent = '▲';

                        // Scroll to first match
                        if (!foundMatch) {
                            heading.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }
                });
            }

            // Add event listeners for both Enter key and search icon
            document.getElementById('searchInput').addEventListener('keypress', function (event) {
                if (event.key === 'Enter') {
                    performSearch();
                }
            });
                 function toggleUrls(event) {

               const urlList = event.target.closest('.block-heading').nextElementSibling; // Find the next sibling (url list)

               if (urlList.style.display === 'block') {

                   urlList.style.display = 'none'; // Collapse

                   event.target.innerHTML = '▼'; // Change button to show collapsed state

               } else {

                   urlList.style.display = 'block'; // Expand

                   event.target.innerHTML = '▲'; // Change button to show expanded state

               }

           }


    // Function to add new numbered flow
    document.querySelector('.add-flow-button').addEventListener('click', function() {
        flowCount++;
        const flowList = document.querySelector('.flow-list');
        const newFlow = document.createElement('div');
        newFlow.className = 'flow-item';
        newFlow.textContent = `Flow ${flowCount}`;
        flowList.appendChild(newFlow);
    });
</script>


{% endblock %}

</body>

</html>